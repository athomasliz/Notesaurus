"use strict";(self.webpackChunknotesaurus=self.webpackChunknotesaurus||[]).push([[2276],{4153:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>m,contentTitle:()=>n,default:()=>k,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var l=a(7462),r=(a(7294),a(3905)),o=a(1839);const i={sidebar_position:1},n="JVM",s={unversionedId:"java/jvm",id:"java/jvm",title:"JVM",description:"Notes",source:"@site/docs/java/jvm.md",sourceDirName:"java",slug:"/java/jvm",permalink:"/Notesaurus/docs/java/jvm",draft:!1,editUrl:"https://github.com/athomasliz/Notesaurus/tree/main/docs/java/jvm.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"iOS Distribution",permalink:"/Notesaurus/docs/react-native/Miscellaneous/ios-distribution"},next:{title:"Misc",permalink:"/Notesaurus/docs/java/misc"}},m={},p=[{value:"Notes",id:"notes",level:3},{value:"Reference",id:"reference",level:3},{value:"Books",id:"books",level:3}],c={toc:p};function k(e){let{components:t,...i}=e;return(0,r.kt)("wrapper",(0,l.Z)({},c,i,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"jvm"},"JVM"),(0,r.kt)("h3",{id:"notes"},"Notes"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"From source code to JVM",(0,r.kt)(o.G,{parentName:"li",config:'{"theme":{"light":"neutral","dark":"forest"},"themeVariables":{"lineColor":"#9CCC65"}}',chart:"   flowchart LR;\n   A1[Java source code <br/>.java files]--\x3eB1[Java Compiler]--\x3eC[bytecode <br/>.class files]--\x3eD1[JVM for Windows]--\x3eE1[fa:fa-windows Windows]\n   A2[Kotlin source code <br/>.kt files]--\x3eB2[Kotlin Compiler]--\x3eC\n   A3[Scala source code <br/>.sc files]--\x3eB3[Scala Compiler]--\x3eC\n   C--\x3eD2[JVM for Linux]--\x3eE2[fa:fa-linux Linix]\n   C--\x3eD3[JVM for macOS]--\x3eE3[fa:fa-apple macOS]       ",mdxType:"Mermaid"})),(0,r.kt)("li",{parentName:"ol"},"JVM Overview\n",(0,r.kt)("a",{target:"_blank",href:a(5732).Z},(0,r.kt)("img",{alt:"JVM Overview",src:a(5807).Z,width:"1123",height:"794"}))),(0,r.kt)("li",{parentName:"ol"},"Runtime data areas",(0,r.kt)("ol",{parentName:"li"},(0,r.kt)("li",{parentName:"ol"},"PC registers (Call stack)",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"What code and which line of code being executed is being held here"),(0,r.kt)("li",{parentName:"ul"},"Hold the address of the instruction"),(0,r.kt)("li",{parentName:"ul"},"Know the sequence of instructions that needs to be executed"),(0,r.kt)("li",{parentName:"ul"},"Each thread has its own PC register"))),(0,r.kt)("li",{parentName:"ol"},"Stack area",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Linear data structure"),(0,r.kt)("li",{parentName:"ul"},"Where the ",(0,r.kt)("strong",{parentName:"li"},"primitives")," and ",(0,r.kt)("strong",{parentName:"li"},"references to the heap")," are stored"),(0,r.kt)("li",{parentName:"ul"},"Each thread has its own stack"),(0,r.kt)("li",{parentName:"ul"},"Each stack has ",(0,r.kt)("strong",{parentName:"li"},"frames")),(0,r.kt)("li",{parentName:"ul"},"Each frame is created for each method call"),(0,r.kt)("li",{parentName:"ul"},"When method A calls method B, a new frame for method B is created. This new frame will then become the ",(0,r.kt)("strong",{parentName:"li"},"current frame"),", and also the ",(0,r.kt)("strong",{parentName:"li"},"top frame")," of the stack. The stack has access to this top frame only."),(0,r.kt)("li",{parentName:"ul"},"Each frame is removed after method execution."),(0,r.kt)("li",{parentName:"ul"},"Each frame consists of the following:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Local variable array",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"For instance method, the first element is the reference to the object itself, i.e. this."))),(0,r.kt)("li",{parentName:"ul"},"Frame data",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"consists of data needed to execute the method. Examples: reference to the constant pool."))),(0,r.kt)("li",{parentName:"ul"},"Operand stack"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"StackOverFlowError")," is thrown if stack memory is too small for the frame"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"OutOfMemoryError")," is thrown if not enough space for a new stack for a new thread"))),(0,r.kt)("li",{parentName:"ol"},"Heap area",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Hierarchical data structure"),(0,r.kt)("li",{parentName:"ul"},"Where the ",(0,r.kt)("strong",{parentName:"li"},"object")," is stored"),(0,r.kt)("li",{parentName:"ul"},"Dynamic memory allocation"),(0,r.kt)("li",{parentName:"ul"},"Garbage collection by JVM here"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"OutOfMemoryError")," is thrown when running out of heap memory"))),(0,r.kt)("li",{parentName:"ol"},"Method area (Metaspace)",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Class's metadata",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Klass"),(0,r.kt)("li",{parentName:"ul"},"Bytecode"),(0,r.kt)("li",{parentName:"ul"},"Static variables"),(0,r.kt)("li",{parentName:"ul"},"Constant pools"),(0,r.kt)("li",{parentName:"ul"},"Constructor code"),(0,r.kt)("li",{parentName:"ul"},"Annotation   "))))),(0,r.kt)("li",{parentName:"ol"},"Native method stack area",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"a.k.a. C stack"))))),(0,r.kt)("li",{parentName:"ol"},"Stack or Heap: where are things actually stored?",(0,r.kt)("ol",{parentName:"li"},(0,r.kt)("li",{parentName:"ol"},"Primitives and wrapper classes",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Both are immutable"),(0,r.kt)("li",{parentName:"ul"},"Primitive for the stack frame is stored on the stack"),(0,r.kt)("li",{parentName:"ul"},"Primitive belongs to the object (as instance variable) is stored together with the object on the heap"),(0,r.kt)("li",{parentName:"ul"},"All wrapper class objects are stored on the heap"))),(0,r.kt)("li",{parentName:"ol"},"References",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Can be stored on both the stack and the heap"),(0,r.kt)("li",{parentName:"ul"},"Local variable: stack"),(0,r.kt)("li",{parentName:"ul"},"Instance variable: heap"))),(0,r.kt)("li",{parentName:"ol"},"Objects",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Always on the heap"),(0,r.kt)("li",{parentName:"ul"},"String is stored in String Pool (a.k.a. String Constant Pool) in the heap"))))),(0,r.kt)("li",{parentName:"ol"},"Call-by-value vs Call-by-reference",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Call-by-value: passing parameters as ",(0,r.kt)("strong",{parentName:"li"},"copy"),". Hence immutable."),(0,r.kt)("li",{parentName:"ul"},"Call-by-reference: passing parameters as ",(0,r.kt)("strong",{parentName:"li"},"reference"),". ",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The object being referred to is mutable. Anyone who get its reference can mutate the object, even it is declared private."),(0,r.kt)("li",{parentName:"ul"},"Problem: Violate the proper encapsulation"),(0,r.kt)("li",{parentName:"ul"},"Solution: Defensive copying, Deep copy on both the way in and out            "))))),(0,r.kt)("li",{parentName:"ol"},"Garbage Collection",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Eligibility of object for GC: whether the object can be deallocated from memory"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"GC root")," (Garbage collection root): special type of live object not eligible for GC"),(0,r.kt)("li",{parentName:"ul"},"All objects reachable from GC roots are not eligible for GC"),(0,r.kt)("li",{parentName:"ul"},"GC root includes:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Local variable"),(0,r.kt)("li",{parentName:"ul"},"Static variable"),(0,r.kt)("li",{parentName:"ul"},"Active Java threads"),(0,r.kt)("li",{parentName:"ul"},"Native references"))),(0,r.kt)("li",{parentName:"ul"},"Generational GC: divide memory into young and old generation"),(0,r.kt)("li",{parentName:"ul"},"Minor GC",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Triggered when eden is full"),(0,r.kt)("li",{parentName:"ul"},"GC on young generation"),(0,r.kt)("li",{parentName:"ul"},"Move live objects from young generation to old generation"),(0,r.kt)("li",{parentName:"ul"},"Algorithm: ",(0,r.kt)("strong",{parentName:"li"},"Mark and Copy"),". For newbie, google details for minor GC.",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Survivor space is deliberately divided into S0 and S1. This is for the purpose of copying"),(0,r.kt)("li",{parentName:"ul"},"S0 and S1 takes turn as the target copying space"),(0,r.kt)("li",{parentName:"ul"},"Take S1 to be the target copying space. For live objects in different places, do the following:",(0,r.kt)("ol",{parentName:"li"},(0,r.kt)("li",{parentName:"ol"},"At S1",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"For live objects that reach their live threshold, copy to old generation"),(0,r.kt)("li",{parentName:"ul"},"clear only the live objects above in S1"))),(0,r.kt)("li",{parentName:"ol"},"At eden",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"copy to S1"),(0,r.kt)("li",{parentName:"ul"},"clear the whole eden"))),(0,r.kt)("li",{parentName:"ol"},"At S0 ",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"copy to S1"),(0,r.kt)("li",{parentName:"ul"},"clear the whole S0                "))),(0,r.kt)("li",{parentName:"ol"},"Incoming new objects",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"copy to eden    "))))))))),(0,r.kt)("li",{parentName:"ul"},"Major GC",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Triggered when tenured is full"),(0,r.kt)("li",{parentName:"ul"},"GC on old generation"),(0,r.kt)("li",{parentName:"ul"},"Algorithm: ",(0,r.kt)("strong",{parentName:"li"},"Mark Sweep Compact"))))))),(0,r.kt)("h3",{id:"reference"},"Reference"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://stackoverflow.com/questions/77046489/java-how-to-avoid-stop-the-world-garbage-collection"},"java how to avoid stop-the-world garbage collection")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://stackoverflow.com/questions/40182392/does-java-garbage-collect-always-has-to-stop-the-world"},'Does Java Garbage Collect always has to "Stop-the-World"?')),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://www.zhihu.com/question/29114369?utm_id=0"},"minor gc \u4f1a\u53d1\u751fstop the world \u73b0\u8c61\u5417\uff1f")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://blog.csdn.net/qq_34988304/article/details/105381353"},"GC \u7b97\u6cd5(\u57fa\u7840\u7bc7)")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://iq.opengenus.org/memory-management-in-java-mark-sweep-compact-copy/"},"Mark Sweep Compact Copy algorithm"))),(0,r.kt)("h3",{id:"books"},"Books"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://learning.oreilly.com/library/view/java-memory-management/9781801812856/"},(0,r.kt)("img",{parentName:"a",src:"https://learning.oreilly.com/covers/urn:orm:book:9781801812856/160h/",alt:"Java Memory Management"}))))}k.isMDXComponent=!0},5732:(e,t,a)=>{a.d(t,{Z:()=>l});const l=a.p+"assets/files/jvm-memory-b06c3a7420505bba93ace34fd32641cc.svg"},5807:(e,t,a)=>{a.d(t,{Z:()=>l});const l=a.p+"assets/images/jvm-memory-b06c3a7420505bba93ace34fd32641cc.svg"}}]);