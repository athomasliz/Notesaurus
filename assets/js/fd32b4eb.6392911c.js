"use strict";(self.webpackChunknotesaurus=self.webpackChunknotesaurus||[]).push([[2276],{4153:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>m,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var r=a(7462),l=(a(7294),a(3905)),n=a(1839);const i={sidebar_position:1},o="Day 0: JVM",s={unversionedId:"java/jvm",id:"java/jvm",title:"Day 0: JVM",description:"Notes",source:"@site/docs/java/jvm.md",sourceDirName:"java",slug:"/java/jvm",permalink:"/Notesaurus/docs/java/jvm",draft:!1,editUrl:"https://github.com/athomasliz/Notesaurus/tree/main/docs/java/jvm.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"iOS Distribution",permalink:"/Notesaurus/docs/react-native/Miscellaneous/ios-distribution"},next:{title:"Day 0: Spring Boot 101",permalink:"/Notesaurus/docs/spring-boot/101"}},m={},p=[{value:"Notes",id:"notes",level:3},{value:"Reference",id:"reference",level:3}],c={toc:p};function u(e){let{components:t,...i}=e;return(0,l.kt)("wrapper",(0,r.Z)({},c,i,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"day-0-jvm"},"Day 0: JVM"),(0,l.kt)("h3",{id:"notes"},"Notes"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"From source code to JVM",(0,l.kt)(n.G,{parentName:"li",config:'{"theme":{"light":"neutral","dark":"forest"},"themeVariables":{"lineColor":"#9CCC65"}}',chart:"   flowchart LR;\n   A1[Java source code <br/>.java files]--\x3eB1[Java Compiler]--\x3eC[bytecode <br/>.class files]--\x3eD1[JVM for Windows]--\x3eE1[fa:fa-windows Windows]\n   A2[Kotlin source code <br/>.kt files]--\x3eB2[Kotlin Compiler]--\x3eC\n   A3[Scala source code <br/>.sc files]--\x3eB3[Scala Compiler]--\x3eC\n   C--\x3eD2[JVM for Linux]--\x3eE2[fa:fa-linux Linix]\n   C--\x3eD3[JVM for macOS]--\x3eE3[fa:fa-apple macOS]       ",mdxType:"Mermaid"})),(0,l.kt)("li",{parentName:"ol"},"JVM Overview\n",(0,l.kt)("a",{target:"_blank",href:a(5732).Z},(0,l.kt)("img",{alt:"JVM Overview",src:a(5807).Z,width:"1123",height:"794"}))),(0,l.kt)("li",{parentName:"ol"},"Runtime data areas",(0,l.kt)("ol",{parentName:"li"},(0,l.kt)("li",{parentName:"ol"},"PC registers (Call stack)",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"What code and which line of code being executed is being held here"),(0,l.kt)("li",{parentName:"ul"},"Hold the address of the instruction"),(0,l.kt)("li",{parentName:"ul"},"Know the sequence of instructions that needs to be executed"),(0,l.kt)("li",{parentName:"ul"},"Each thread has its own PC register"))),(0,l.kt)("li",{parentName:"ol"},"Stack area",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Linear data structure"),(0,l.kt)("li",{parentName:"ul"},"Where the ",(0,l.kt)("strong",{parentName:"li"},"primitives")," and ",(0,l.kt)("strong",{parentName:"li"},"references to the heap")," are stored"),(0,l.kt)("li",{parentName:"ul"},"Each thread has its own stack"),(0,l.kt)("li",{parentName:"ul"},"Each stack has ",(0,l.kt)("strong",{parentName:"li"},"frames")),(0,l.kt)("li",{parentName:"ul"},"Each frame is created for each method call"),(0,l.kt)("li",{parentName:"ul"},"When method A calls method B, a new frame for method B is created. This new frame will then become the ",(0,l.kt)("strong",{parentName:"li"},"current frame"),", and also the ",(0,l.kt)("strong",{parentName:"li"},"top frame")," of the stack. The stack has access to this top frame only."),(0,l.kt)("li",{parentName:"ul"},"Each frame is removed after method execution."),(0,l.kt)("li",{parentName:"ul"},"Each frame consists of the following:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Local variable array",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"For instance method, the first element is the reference to the object itself, i.e. this."))),(0,l.kt)("li",{parentName:"ul"},"Frame data",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"consists of data needed to execute the method. Examples: reference to the constant pool."))),(0,l.kt)("li",{parentName:"ul"},"Operand stack"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"StackOverFlowError")," is thrown if stack memory is too small for the frame"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"OutOfMemoryError")," is thrown if not enough space for a new stack for a new thread"))),(0,l.kt)("li",{parentName:"ol"},"Heap area",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Hierarchical data structure"),(0,l.kt)("li",{parentName:"ul"},"Where the ",(0,l.kt)("strong",{parentName:"li"},"object")," is stored"),(0,l.kt)("li",{parentName:"ul"},"Dynamic memory allocation"),(0,l.kt)("li",{parentName:"ul"},"Garbage collection by JVM here"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"OutOfMemoryError")," is thrown when running out of heap memory"))),(0,l.kt)("li",{parentName:"ol"},"Method area (Metaspace)",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Class's metadata",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Klass"),(0,l.kt)("li",{parentName:"ul"},"Bytecode"),(0,l.kt)("li",{parentName:"ul"},"Static variables"),(0,l.kt)("li",{parentName:"ul"},"Constant pools"),(0,l.kt)("li",{parentName:"ul"},"Constructor code"),(0,l.kt)("li",{parentName:"ul"},"Annotation   "))))),(0,l.kt)("li",{parentName:"ol"},"Native method stack area",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"a.k.a. C stack"))))),(0,l.kt)("li",{parentName:"ol"},"Stack or Heap: where are things actually stored?",(0,l.kt)("ol",{parentName:"li"},(0,l.kt)("li",{parentName:"ol"},"Primitives and wrapper classes",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Both are immutable"),(0,l.kt)("li",{parentName:"ul"},"Primitive for the stack frame is stored on the stack"),(0,l.kt)("li",{parentName:"ul"},"Primitive belongs to the object (as instance variable) is stored together with the object on the heap"),(0,l.kt)("li",{parentName:"ul"},"All wrapper class objects are stored on the heap"))),(0,l.kt)("li",{parentName:"ol"},"References",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Can be stored on both the stack and the heap"),(0,l.kt)("li",{parentName:"ul"},"Local variable: stack"),(0,l.kt)("li",{parentName:"ul"},"Instance variable: heap"))),(0,l.kt)("li",{parentName:"ol"},"Objects",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Always on the heap"),(0,l.kt)("li",{parentName:"ul"},"String is stored in String Pool (a.k.a. String Constant Pool) in the heap"))))),(0,l.kt)("li",{parentName:"ol"},"Call-by-value vs Call-by-reference",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Call-by-value: passing parameters as ",(0,l.kt)("strong",{parentName:"li"},"copy"),". Hence immutable."),(0,l.kt)("li",{parentName:"ul"},"Call-by-reference: passing parameters as ",(0,l.kt)("strong",{parentName:"li"},"reference"),". ",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"The object being referred to is mutable. Anyone who get its reference can mutate the object, even it is declared private."),(0,l.kt)("li",{parentName:"ul"},"Problem: Violate the proper encapsulation"),(0,l.kt)("li",{parentName:"ul"},"Solution: Defensive copying, Deep copy on both the way in and out            "))))),(0,l.kt)("li",{parentName:"ol"},"Garbage Collection",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Eligibility of object for GC: whether the object can be deallocated from memory"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"GC root")," (Garbage collection root): special type of live object not eligible for GC"),(0,l.kt)("li",{parentName:"ul"},"All objects reachable from GC roots are not eligible for GC"),(0,l.kt)("li",{parentName:"ul"},"GC root includes:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Local variable"),(0,l.kt)("li",{parentName:"ul"},"Static variable"),(0,l.kt)("li",{parentName:"ul"},"Active Java threads"),(0,l.kt)("li",{parentName:"ul"},"Native references"))),(0,l.kt)("li",{parentName:"ul"},"Generational GC: divide memory into yound and old generation"),(0,l.kt)("li",{parentName:"ul"},"Minor GC",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Triggered when eden is full"),(0,l.kt)("li",{parentName:"ul"},"GC on young generation"),(0,l.kt)("li",{parentName:"ul"},"Move live objects from young generation to old generation"),(0,l.kt)("li",{parentName:"ul"},"Algorithm: ",(0,l.kt)("strong",{parentName:"li"},"Mark and Copy"),"        "))),(0,l.kt)("li",{parentName:"ul"},"Major GC",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Triggered when tenured is full"),(0,l.kt)("li",{parentName:"ul"},"GC on old generation"),(0,l.kt)("li",{parentName:"ul"},"Algorithm: ",(0,l.kt)("strong",{parentName:"li"},"Mark and Compact"))))))),(0,l.kt)("h3",{id:"reference"},"Reference"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"https://learning.oreilly.com/library/view/java-memory-management/9781801812856/"},(0,l.kt)("img",{parentName:"a",src:"https://learning.oreilly.com/covers/urn:orm:book:9781801812856/160h/",alt:"Java Memory Management"})))))}u.isMDXComponent=!0},5732:(e,t,a)=>{a.d(t,{Z:()=>r});const r=a.p+"assets/files/jvm-memory-b06c3a7420505bba93ace34fd32641cc.svg"},5807:(e,t,a)=>{a.d(t,{Z:()=>r});const r=a.p+"assets/images/jvm-memory-b06c3a7420505bba93ace34fd32641cc.svg"}}]);