"use strict";(self.webpackChunknotesaurus=self.webpackChunknotesaurus||[]).push([[6788],{1866:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>c,frontMatter:()=>l,metadata:()=>o,toc:()=>p});var n=a(7462),i=(a(7294),a(3905));a(1839);const l={sidebar_position:1},r="Core Java",o={unversionedId:"java/core",id:"java/core",title:"Core Java",description:"Below notes are based on the book OCP Oracle Certified Professional Java SE 17 Developer Study Guide.",source:"@site/docs/java/core.md",sourceDirName:"java",slug:"/java/core",permalink:"/Notesaurus/docs/java/core",draft:!1,editUrl:"https://github.com/athomasliz/Notesaurus/tree/main/docs/java/core.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"iOS Distribution",permalink:"/Notesaurus/docs/react-native/Miscellaneous/ios-distribution"},next:{title:"JVM",permalink:"/Notesaurus/docs/java/jvm"}},s={},p=[{value:"Building Blocks",id:"building-blocks",level:2},{value:"Environment",id:"environment",level:3},{value:"Class Structure",id:"class-structure",level:3},{value:"Field and Method",id:"field-and-method",level:4},{value:"Classes and Source Files",id:"classes-and-source-files",level:4},{value:"main() method",id:"main-method",level:4},{value:"Package and Import",id:"package-and-import",level:3},{value:"Compilation, Execution and JAR files",id:"compilation-execution-and-jar-files",level:3},{value:"Ordering elements in a class",id:"ordering-elements-in-a-class",level:3},{value:"Creating objects",id:"creating-objects",level:3},{value:"Primitive Type and Literals",id:"primitive-type-and-literals",level:3},{value:"Reference Type",id:"reference-type",level:3},{value:"Primitive Type vs Reference Type",id:"primitive-type-vs-reference-type",level:3},{value:"Wrapper Class",id:"wrapper-class",level:3},{value:"Text Block",id:"text-block",level:3},{value:"Declaring variables",id:"declaring-variables",level:3},{value:"Case convention",id:"case-convention",level:3},{value:"Declaring multiple variables",id:"declaring-multiple-variables",level:3},{value:"Initializing variables",id:"initializing-variables",level:3},{value:"Using var for local variable",id:"using-var-for-local-variable",level:3},{value:"Variable scope",id:"variable-scope",level:3},{value:"Garbage collection",id:"garbage-collection",level:3},{value:"Operators",id:"operators",level:2},{value:"Order of operator precedence",id:"order-of-operator-precedence",level:3},{value:"Unary Operators",id:"unary-operators",level:3},{value:"Binary Arithemtic Operators",id:"binary-arithemtic-operators",level:3},{value:"Numeric Promotion",id:"numeric-promotion",level:3},{value:"Assignment Operator",id:"assignment-operator",level:3},{value:"Compound Assignment Operators",id:"compound-assignment-operators",level:3},{value:"Equality Operators",id:"equality-operators",level:3},{value:"Relational Operators",id:"relational-operators",level:3},{value:"Logical Operator",id:"logical-operator",level:3},{value:"Conditional Operator",id:"conditional-operator",level:3},{value:"Ternary Operator",id:"ternary-operator",level:3},{value:"Control Flow Statement",id:"control-flow-statement",level:2},{value:"<em>if</em> statement",id:"if-statement",level:3},{value:"Pattern matching (Java 14)",id:"pattern-matching-java-14",level:4},{value:"<em>switch</em> statement",id:"switch-statement",level:3},{value:"<em>switch</em> expression (Java 14)",id:"switch-expression-java-14",level:4},{value:"<em>while</em> statement",id:"while-statement",level:3},{value:"<em>do while</em> statement",id:"do-while-statement",level:3},{value:"<em>for</em> loop",id:"for-loop",level:3},{value:"<em>for each</em> loop",id:"for-each-loop",level:3},{value:"Branching",id:"branching",level:3},{value:"Nested Loop",id:"nested-loop",level:4},{value:"Optional label",id:"optional-label",level:4},{value:"<em>break</em> statement",id:"break-statement",level:4},{value:"<em>continue</em> statement",id:"continue-statement",level:4},{value:"<em>return</em> statement",id:"return-statement",level:4},{value:"Unreachable Code",id:"unreachable-code",level:4},{value:"Support for labels, <code>break</code>, <code>continue</code> and <code>yield</code>",id:"support-for-labels-break-continue-and-yield",level:4},{value:"Core APIs",id:"core-apis",level:2},{value:"String",id:"string",level:3},{value:"StringBuilder",id:"stringbuilder",level:3},{value:"Equality",id:"equality",level:3},{value:"Array",id:"array",level:3},{value:"Math API",id:"math-api",level:3},{value:"Date and Time",id:"date-and-time",level:3},{value:"Methods",id:"methods",level:2},{value:"Introduction",id:"introduction",level:3},{value:"Access Modifier",id:"access-modifier",level:4},{value:"Optional Specifier",id:"optional-specifier",level:4},{value:"Return Type",id:"return-type",level:4},{value:"Method Name",id:"method-name",level:4},{value:"Parameter List",id:"parameter-list",level:4},{value:"Method Signature",id:"method-signature",level:4},{value:"Exception List",id:"exception-list",level:4},{value:"Method Body",id:"method-body",level:4},{value:"Local variables and Instance variables",id:"local-variables-and-instance-variables",level:3},{value:"Methods with Varargs",id:"methods-with-varargs",level:3},{value:"Static",id:"static",level:3},{value:"Pass by value",id:"pass-by-value",level:3},{value:"Returning data",id:"returning-data",level:3},{value:"Autoboxing and Unboxing",id:"autoboxing-and-unboxing",level:3},{value:"Overloading",id:"overloading",level:3},{value:"Class Design",id:"class-design",level:2},{value:"Inheritance",id:"inheritance",level:3},{value:"java.lang.Object",id:"javalangobject",level:3},{value:"Access modifier",id:"access-modifier-1",level:3},{value:"<code>this</code>",id:"this",level:3},{value:"<code>super</code>",id:"super",level:3},{value:"Constructor",id:"constructor",level:3},{value:"Initialization",id:"initialization",level:3},{value:"Overriding and Hiding",id:"overriding-and-hiding",level:3},{value:"Abstract Class",id:"abstract-class",level:3},{value:"Immutable Object",id:"immutable-object",level:3},{value:"Beyond Classes",id:"beyond-classes",level:2},{value:"Top level type",id:"top-level-type",level:3},{value:"Interface",id:"interface",level:3},{value:"Lambdas And Functional Interfaces",id:"lambdas-and-functional-interfaces",level:2}],m={toc:p};function c(e){let{components:t,...a}=e;return(0,i.kt)("wrapper",(0,n.Z)({},m,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"core-java"},"Core Java"),(0,i.kt)("p",null,"Below notes are based on the book ",(0,i.kt)("em",{parentName:"p"},"OCP Oracle Certified Professional Java SE 17 Developer Study Guide"),"."),(0,i.kt)("h2",{id:"building-blocks"},"Building Blocks"),(0,i.kt)("h3",{id:"environment"},"Environment"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"JDK"),": Java Development Kit",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"javac"),": Convert .java (source file) into .class (bytecode)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"java"),": Execute"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"jar"),": Package"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"javadoc"),": Document"))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"JRE"),": Java Runtime Environment",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"subset of JDK"),(0,i.kt)("li",{parentName:"ul"},"could not compile"))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"IDE"),": Integrated Development Environment")),(0,i.kt)("h3",{id:"class-structure"},"Class Structure"),(0,i.kt)("h4",{id:"field-and-method"},"Field and Method"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Method"),": a.k.a. function / procedure in other languages"),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Field"),": a.k.a. variable"),(0,i.kt)("li",{parentName:"ol"},"Method and Field are ",(0,i.kt)("strong",{parentName:"li"},"Member")," of the ",(0,i.kt)("strong",{parentName:"li"},"Class"),"."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"void"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"special return type"),(0,i.kt)("li",{parentName:"ul"},"no value is returned"))),(0,i.kt)("li",{parentName:"ol"},"Method name and parameter types are called the ",(0,i.kt)("strong",{parentName:"li"},"Method Signature"),".")),(0,i.kt)("h4",{id:"classes-and-source-files"},"Classes and Source Files"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Class")," is a ",(0,i.kt)("strong",{parentName:"li"},"top level type"),"."),(0,i.kt)("li",{parentName:"ol"},"You can put two or more classes in a file."),(0,i.kt)("li",{parentName:"ol"},"At most one of the top level type is allowed to be public."),(0,i.kt)("li",{parentName:"ol"},"If you have a public top level type, it must match the filename.")),(0,i.kt)("h4",{id:"main-method"},"main() method"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"main() method is for execution of the program.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"public static void main(String[] args)\npublic static void main(String args[])\npublic static void main(String... args)\nfinal public static void main(String... args)\n")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"public")," is an access modifier."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"static")," is used as no object needs to be created to run the program."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"...")," is called ",(0,i.kt)("inlineCode",{parentName:"li"},"varargs")," variable argument lists."))),(0,i.kt)("li",{parentName:"ol"},"Compile and run the program with commands below:",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"javac Test.java\njava Test    \n"))),(0,i.kt)("li",{parentName:"ol"},"File extention must be .java."),(0,i.kt)("li",{parentName:"ol"},"The result of compilation is .class file, i.e. bytecode."),(0,i.kt)("li",{parentName:"ol"},"Shortcut for running single file source code.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"java Test.java\n")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Skip explicit compilation step."),(0,i.kt)("li",{parentName:"ul"},"This feature is called ",(0,i.kt)("strong",{parentName:"li"},"launching single-file source code")," programs."),(0,i.kt)("li",{parentName:"ul"},"This feature is designed for when your program is one file.")))),(0,i.kt)("h3",{id:"package-and-import"},"Package and Import"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Package is the logical grouping for classes."),(0,i.kt)("li",{parentName:"ol"},"Package name is hierarchical, separated by period ( . ).",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"package org.irushu;\n"))),(0,i.kt)("li",{parentName:"ol"},"Directory structure is related to the package name."),(0,i.kt)("li",{parentName:"ol"},"Import statement tells which package to look in for classes.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"import org.irushu.MyClass;\n"))),(0,i.kt)("li",{parentName:"ol"},"Use ",(0,i.kt)("strong",{parentName:"li"},"wildcard")," to import all the classes of a package.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"import org.irushu.*;\n"))),(0,i.kt)("li",{parentName:"ol"},"Wildcard can help shorten import list."),(0,i.kt)("li",{parentName:"ol"},"Importing a lot of classes will not slow down execution time."),(0,i.kt)("li",{parentName:"ol"},"Below are limitations for import statements.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Wildcard can only match class names, but it cannot match directories or subdirectories."),(0,i.kt)("li",{parentName:"ul"},"There can only be 1 wildcard, and it must be placed at the end."),(0,i.kt)("li",{parentName:"ul"},"Import statement can only be used to match class names. It cannot match methods or fields."))),(0,i.kt)("li",{parentName:"ol"},"Naming conflicts",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Class names don't have to be unique across all of Java."),(0,i.kt)("li",{parentName:"ul"},"The class name you imported are therefore can be found in multiple places."),(0,i.kt)("li",{parentName:"ul"},"Explicitly importing a class name will take precedence over any wildcard present.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"import java.util.Date; // This will win\nimport java.sql.*;\n"))),(0,i.kt)("li",{parentName:"ul"},"In case you need a class name from 2 different packages, use ",(0,i.kt)("em",{parentName:"li"},"fully qualified class name")," to declare the fields.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"java.util.Date utilDate;\njava.sql.Date sqlDate;\n"))))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"java.lang")," are automatically imported."),(0,i.kt)("li",{parentName:"ol"},"Classes in the same package are automatically imported.")),(0,i.kt)("h3",{id:"compilation-execution-and-jar-files"},"Compilation, Execution and JAR files"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"You can compile as below.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"javac org/irushu/test/Test.java\njavac org/irushu/test/*.java\njavac *.java // This won't compile the source file in package org.irush.test\n"))),(0,i.kt)("li",{parentName:"ol"},"You can use ",(0,i.kt)("strong",{parentName:"li"},"-d")," to place class files in a different directory.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"javac -d classes org/irushu/test/Test.java\n"))),(0,i.kt)("li",{parentName:"ol"},"You can specify the classpath for required libraries to compile the program."),(0,i.kt)("li",{parentName:"ol"},"You can specify the classpath and run the program.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"java -cp classes org.irushu.test.Test\njava -classpath classes org.irushu.test.Test\njava --class-path classes org.irushu.test.Test\n"))),(0,i.kt)("li",{parentName:"ol"},"You can create jar file as below.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"jar -cvf test.jar .\njar -cvf test.jar -C classes . // -C specify the location that contains the class files\njar --create --verbose --file test.jar .\n")))),(0,i.kt)("h3",{id:"ordering-elements-in-a-class"},"Ordering elements in a class"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Elements should be ordered in a class as below.",(0,i.kt)("ol",{parentName:"li"},(0,i.kt)("li",{parentName:"ol"},"Package declaration"),(0,i.kt)("li",{parentName:"ol"},"Import statement"),(0,i.kt)("li",{parentName:"ol"},"Top level type declaration (Class / Interface / Enum)"),(0,i.kt)("li",{parentName:"ol"},"Field declaration"),(0,i.kt)("li",{parentName:"ol"},"Method declaration")))),(0,i.kt)("h3",{id:"creating-objects"},"Creating objects"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"You can define ",(0,i.kt)("strong",{parentName:"li"},"constructor")," for creation of objects."),(0,i.kt)("li",{parentName:"ol"},"Below is an example of constructor. Note it does not have return type.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"public class Test{\n    public Test(){\n        // do something\n    }\n}\n"))),(0,i.kt)("li",{parentName:"ol"},"If you don't provide a constructor, compiler will supply a do nothing default constructor for you."),(0,i.kt)("li",{parentName:"ol"},"You can create object with the ",(0,i.kt)("strong",{parentName:"li"},"new")," keyword.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"Test test = new Test();\n"))),(0,i.kt)("li",{parentName:"ol"},"One can read and write instance variables directly from the caller. ",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'public class Test{\n    String helloWorld = "Hello World";\n    public static void main(String... args){\n        Test test = new Test();\n        test.helloWorld = "Happy Valley";\n    }\n}\n'))),(0,i.kt)("li",{parentName:"ol"},"However, one should honour encapsulation and protect instance variables with access modifier."),(0,i.kt)("li",{parentName:"ol"},"One can define ",(0,i.kt)("strong",{parentName:"li"},"Instance initializer")," as below.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'public class Test{\n   {\n        System.out.println("Test");\n   }\n}\n'))),(0,i.kt)("li",{parentName:"ol"},"Order of execution",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Fields and Instance Initializer run in the order they appeared in the file."),(0,i.kt)("li",{parentName:"ul"},"Constructor"))),(0,i.kt)("li",{parentName:"ol"},"Order matters and you can't refer to a variable before it has been defined.")),(0,i.kt)("h3",{id:"primitive-type-and-literals"},"Primitive Type and Literals"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"There are 8 primitive types.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"byte")," (8), ",(0,i.kt)("strong",{parentName:"li"},"short")," (16), ",(0,i.kt)("strong",{parentName:"li"},"int")," (32), ",(0,i.kt)("strong",{parentName:"li"},"long")," (64)",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Signed"),(0,i.kt)("li",{parentName:"ul"},"Integral value"),(0,i.kt)("li",{parentName:"ul"},"Each numeric type is twice the size as the smaller similar type."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"float")," (32), ",(0,i.kt)("strong",{parentName:"li"},"double")," (64)",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Signed"),(0,i.kt)("li",{parentName:"ul"},"Floating point value"),(0,i.kt)("li",{parentName:"ul"},"Each decimal type is twice the size as the smaller similar type."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"char")," (16)",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Unsigned"),(0,i.kt)("li",{parentName:"ul"},"Unicode value"),(0,i.kt)("li",{parentName:"ul"},"short and char values can be casted to one another as their underlying data size is the same."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"boolean"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"bit size depends on JVM implementation"))))),(0,i.kt)("li",{parentName:"ol"},"When a number, decimal, String or character is present in the code, they are called ",(0,i.kt)("strong",{parentName:"li"},"literals"),"."),(0,i.kt)("li",{parentName:"ol"},"By default java interprets numeric value as int."),(0,i.kt)("li",{parentName:"ol"},"To specify the numeric literal as long, add l or L at the end of it."),(0,i.kt)("li",{parentName:"ol"},"By default java interprets decimal value as double."),(0,i.kt)("li",{parentName:"ol"},"To specify the decimal literal as float, add f or F at the end of it.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"// This will error\nfloat a = 2.0; // Cannot compile\n# highlight-next-line\nfloat b = 2.0f;\n"))),(0,i.kt)("li",{parentName:"ol"},"Although float values can be declared with an f suffix, they are not printed with an f suffix.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"float b = 2.0f;\nSystem.out.println(b); // It will print 0.0\n"))),(0,i.kt)("li",{parentName:"ol"},"One can specify a number by ",(0,i.kt)("strong",{parentName:"li"},"changing base"),". By default it is using decimal number system.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"int a = 017; // Octal (0-7)\nint b = 0xFF; // Hexadecimal (0-9 a-f A-F)\nint c = 0B101; // Binary (0-1)\nSystem.out.println(a); // Print 15\nSystem.out.println(b); // Print 255\nSystem.out.println(c); // Print 5\n"))),(0,i.kt)("li",{parentName:"ol"},"You can put underscores in numbers. ",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"int value = 1_000_000;\n"))),(0,i.kt)("li",{parentName:"ol"},"You cannot put underscore at the beginning or end of a literal, or right before or after a decimal point.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"// This will error\ndouble a = _999.00; // CANNOT COMPILE\n// This will error\ndouble b = 999.00_; // CANNOT COMPILE\n// This will error\ndouble c = 999._00; // CANNOT COMPILE\n// This will error\ndouble d = 999_.00; // CANNOT COMPILE\n")))),(0,i.kt)("h3",{id:"reference-type"},"Reference Type"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"A ",(0,i.kt)("strong",{parentName:"li"},"reference type")," refers to an object."),(0,i.kt)("li",{parentName:"ol"},"A ",(0,i.kt)("strong",{parentName:"li"},"reference")," \u201cpoints\u201d to an object by storing the memory address where the object is located."),(0,i.kt)("li",{parentName:"ol"},"A reference is like a ",(0,i.kt)("strong",{parentName:"li"},"pointer"),"."),(0,i.kt)("li",{parentName:"ol"},"A reference can be assigned to another object."),(0,i.kt)("li",{parentName:"ol"},"A reference can be assigned to new object.")),(0,i.kt)("h3",{id:"primitive-type-vs-reference-type"},"Primitive Type vs Reference Type"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Primitive types have lowercase type names."),(0,i.kt)("li",{parentName:"ol"},"Reference types have uppercase type names."),(0,i.kt)("li",{parentName:"ol"},"Reference types can be used to call methods."),(0,i.kt)("li",{parentName:"ol"},"Primitive types do not have methods declared on them."),(0,i.kt)("li",{parentName:"ol"},"If primitive types are unknown, assign null to their wrapper class.")),(0,i.kt)("h3",{id:"wrapper-class"},"Wrapper Class"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"valueOf to convert to wrapper class.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'Integer a = Integer.valueOf("456"); // Wrapper\nint b = Integer.parseInt("789"); // Primitive\n'))),(0,i.kt)("li",{parentName:"ol"},"Number classes, Boolean and Character Wrapper classes have userful helper methods:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"byteValue(), shortValue(), intValue(), longValue()"),(0,i.kt)("li",{parentName:"ul"},"floatValue(), doubleValue()"),(0,i.kt)("li",{parentName:"ul"},"booleanValue()"),(0,i.kt)("li",{parentName:"ul"},"charValue()"))),(0,i.kt)("li",{parentName:"ol"},"Helper classes do their best to convert values but can result in a loss of precision.")),(0,i.kt)("h3",{id:"text-block"},"Text Block"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},'"""')," as Start text block and End text block."),(0,i.kt)("li",{parentName:"ol"},"Incidental whitespace"),(0,i.kt)("li",{parentName:"ol"},"Essential whitespace"),(0,i.kt)("li",{parentName:"ol"},"Escape characters")),(0,i.kt)("h3",{id:"declaring-variables"},"Declaring variables"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"An ",(0,i.kt)("strong",{parentName:"li"},"identifier")," is the name of a variable, method, class, interface, or package."),(0,i.kt)("li",{parentName:"ol"},"Identifiers must begin with letter, a currency symbol or undercore symbol _ ."),(0,i.kt)("li",{parentName:"ol"},"Currency symbol includes dollar ($), yuan (\xa5), euro (\u20ac)."),(0,i.kt)("li",{parentName:"ol"},"A single underscore is not allowed."),(0,i.kt)("li",{parentName:"ol"},"Cannot use reserve word."),(0,i.kt)("li",{parentName:"ol"},"Cannot use literal values like true, false or null.")),(0,i.kt)("h3",{id:"case-convention"},"Case convention"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Method or Field names are declared as ",(0,i.kt)("strong",{parentName:"li"},"lowercase camel")," case."),(0,i.kt)("li",{parentName:"ol"},"Constants or enum values are declared as ",(0,i.kt)("strong",{parentName:"li"},"uppercase snake")," case."),(0,i.kt)("li",{parentName:"ol"},"Class and Interface names are declared as ",(0,i.kt)("strong",{parentName:"li"},"uppercase camel")," case.")),(0,i.kt)("h3",{id:"declaring-multiple-variables"},"Declaring multiple variables"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'String str1, str2, str3="Foo";\n// This will error\nint int1, float float1; // There can only be one type of declaration in a statement.\n// This will error\nString str4, String str5; // You cannot repeat the same declaration in a statement, even they are the same.\ndouble double1; double double2; // Semicolon separates statements, so there is no violation.\n// This will error\nboolean boolean1; boolean2; Invalid declaration for boolean 2 as type is omitted.\n')),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"You can declare many variables in the same declaration as long as they are all of the same type."),(0,i.kt)("li",{parentName:"ol"},"You cannot repeat the same declaration."),(0,i.kt)("li",{parentName:"ol"},"There can only be one declaration, no other declaration can be made.")),(0,i.kt)("h3",{id:"initializing-variables"},"Initializing variables"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Local variable")," is a variable defined within a constructor, method, or initializer block."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"final")," modifier is equivalent to declaring constants."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"final")," modifier can apply to local variable."),(0,i.kt)("li",{parentName:"ol"},"For ",(0,i.kt)("inlineCode",{parentName:"li"},"final")," variable of primitive type, you cannot change its value once it is initiailized."),(0,i.kt)("li",{parentName:"ol"},"For ",(0,i.kt)("inlineCode",{parentName:"li"},"final")," variable of reference type, you cannot change the reference, but you can modify the content the reference points to."),(0,i.kt)("li",{parentName:"ol"},"Local variables do not have ",(0,i.kt)("strong",{parentName:"li"},"default value"),"."),(0,i.kt)("li",{parentName:"ol"},"Local variables must be initialized before use."),(0,i.kt)("li",{parentName:"ol"},"For local variables that have never be used, compiler doesn't care if they are not initialized."),(0,i.kt)("li",{parentName:"ol"},"Compiler is clever enough to determine whether the local variable has been used or not."),(0,i.kt)("li",{parentName:"ol"},"If you pass uninitialized parameters to constructor or method, the program will fail to compile."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Instance variable")," is a field defined within a specific instance of object."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Class variable")," is defined on the class level and shared among all instances of the class."),(0,i.kt)("li",{parentName:"ol"},"Both instance and class variables are given a default value once declared. You don't need to initialize them."),(0,i.kt)("li",{parentName:"ol"},"Initialization of instance and class variables sticks to below rules.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"null for an object"),(0,i.kt)("li",{parentName:"ul"},"0 for numeric types"),(0,i.kt)("li",{parentName:"ul"},"0.0 for decimal types"),(0,i.kt)("li",{parentName:"ul"},"false for boolean"),(0,i.kt)("li",{parentName:"ul"},"'\\u000' for char"))),(0,i.kt)("li",{parentName:"ol"},"Java does not support setting default method parameter values.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"    // This will error\n    public void method(int hello = 3){\n    }\n")))),(0,i.kt)("h3",{id:"using-var-for-local-variable"},"Using var for local variable"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"You can use keyword ",(0,i.kt)("inlineCode",{parentName:"li"},"var")," to declare local variables under certain circumstances."),(0,i.kt)("li",{parentName:"ol"},"This feature is called ",(0,i.kt)("strong",{parentName:"li"},"local variable type inference"),"."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"var")," is ",(0,i.kt)("strong",{parentName:"li"},"only")," used for ",(0,i.kt)("strong",{parentName:"li"},"local variables"),"."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"var")," will instruct the compiler to determine the type."),(0,i.kt)("li",{parentName:"ol"},"In javascript, ",(0,i.kt)("inlineCode",{parentName:"li"},"var")," can take on any type."),(0,i.kt)("li",{parentName:"ol"},"But in java, compiler will determine the specific type for ",(0,i.kt)("inlineCode",{parentName:"li"},"var"),". The type cannot be changed during runtime."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"var")," variable cannot be initialized to null during declaration. Compiler cannot infer its type."),(0,i.kt)("li",{parentName:"ol"},"If the underlying type is a reference type, ",(0,i.kt)("inlineCode",{parentName:"li"},"var")," variable can be reassigned with null value after declaration."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"var")," cannot be used in multiple variable assignment."),(0,i.kt)("li",{parentName:"ol"},"For ",(0,i.kt)("inlineCode",{parentName:"li"},"var"),", compiler will look only at the line of declaration. variable must be assigned values on the lines where they are defined.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'void methodA(){\n    var a = "String A";\n    var b\n        = 5;\n    // This will error\n    var c; // var variable is not assigned with values on the same line they are declared.\n    c = 1;\n    // This will error\n    var d = null; // compiler cannot infer the type\n    var e = "String B";\n    e = null;\n    // This will error  \n    var f = 2, g = 2; // var cannot be used in multiple variable assignment\n}\n'))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"var")," cannot be used on method parameters.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"}," // This will error\n void methodB(var a, var b){\n \n }\n"))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"var")," is not a reserved word and allowed to be used as an identifier.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'void methodC(){\n    {/* highlight-start */}\n    var var = "hello"; // This will compile\n    {/* highlight-end */}\n}\n')))),(0,i.kt)("h3",{id:"variable-scope"},"Variable scope"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"A set of braces means a new code block."),(0,i.kt)("li",{parentName:"ol"},"Each code block has its own scope."),(0,i.kt)("li",{parentName:"ol"},"Code block can contain another code block. "),(0,i.kt)("li",{parentName:"ol"},"Inner block can reference variables of outer block, but not vice versa."),(0,i.kt)("li",{parentName:"ol"},"Scope for different type of variables",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Local variable: In scope from declaration to the end of the block."),(0,i.kt)("li",{parentName:"ul"},"Method parameters: In scope for the duration of the method."),(0,i.kt)("li",{parentName:"ul"},"Instance variable: In scope from declaration until the object is eligible for gc."),(0,i.kt)("li",{parentName:"ul"},"Class variable: In scope from declaration to end of the program.")))),(0,i.kt)("h3",{id:"garbage-collection"},"Garbage collection"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"For details, refers to ",(0,i.kt)("a",{parentName:"li",href:"/Notesaurus/docs/java/jvm"},"JVM section"),"."),(0,i.kt)("li",{parentName:"ol"},"System.gc() is not guaranteed to do anything. JVM can ignore it.")),(0,i.kt)("h2",{id:"operators"},"Operators"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"An ",(0,i.kt)("strong",{parentName:"li"},"operator")," is a special symbol or operation that can be applied to operands."),(0,i.kt)("li",{parentName:"ol"},"An ",(0,i.kt)("strong",{parentName:"li"},"operand")," is the variable / literal / value the operator being applied to."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"unary"),", ",(0,i.kt)("strong",{parentName:"li"},"binary")," and ",(0,i.kt)("strong",{parentName:"li"},"tenary")," operator take 1, 2 and 3 operand(s) respectively."),(0,i.kt)("li",{parentName:"ol"},"Evaluation can be ",(0,i.kt)("strong",{parentName:"li"},"left-to-right")," or ",(0,i.kt)("strong",{parentName:"li"},"right-to-left"),"."),(0,i.kt)("li",{parentName:"ol"},"Some operators require the operand of specific type.")),(0,i.kt)("h3",{id:"order-of-operator-precedence"},"Order of operator precedence"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Operator should follow below orders"),(0,i.kt)("table",{parentName:"li"},(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Operator"),(0,i.kt)("th",{parentName:"tr",align:null},"Symbols"),(0,i.kt)("th",{parentName:"tr",align:null},"Evaluation"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Post-unary operators"),(0,i.kt)("td",{parentName:"tr",align:null},"expression++, expression--"),(0,i.kt)("td",{parentName:"tr",align:null},"LR")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Pre-unary operators"),(0,i.kt)("td",{parentName:"tr",align:null},"++expression, --expression"),(0,i.kt)("td",{parentName:"tr",align:null},"LR")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Other unary operators"),(0,i.kt)("td",{parentName:"tr",align:null},"-, !, ~, +, (type)"),(0,i.kt)("td",{parentName:"tr",align:null},"Right-to-left")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Cast\t(Type)"),(0,i.kt)("td",{parentName:"tr",align:null},"reference"),(0,i.kt)("td",{parentName:"tr",align:null},"Right-to-left")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Multiplication/division/modulus"),(0,i.kt)("td",{parentName:"tr",align:null},"*, /, %"),(0,i.kt)("td",{parentName:"tr",align:null},"LR")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Addition/subtraction"),(0,i.kt)("td",{parentName:"tr",align:null},"+, -"),(0,i.kt)("td",{parentName:"tr",align:null},"LR")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Shift operators"),(0,i.kt)("td",{parentName:"tr",align:null},"<<, >>, >>>"),(0,i.kt)("td",{parentName:"tr",align:null},"LR")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Relational operators"),(0,i.kt)("td",{parentName:"tr",align:null},"<, >, <=, >=, instanceof"),(0,i.kt)("td",{parentName:"tr",align:null},"LR")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Equal to/not equal to"),(0,i.kt)("td",{parentName:"tr",align:null},"==, !="),(0,i.kt)("td",{parentName:"tr",align:null},"LR")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Logical AND"),(0,i.kt)("td",{parentName:"tr",align:null},"&"),(0,i.kt)("td",{parentName:"tr",align:null},"LR")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Logical exclusive OR"),(0,i.kt)("td",{parentName:"tr",align:null},"^"),(0,i.kt)("td",{parentName:"tr",align:null},"LR")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Logical inclusive OR"),(0,i.kt)("td",{parentName:"tr",align:null},"|"),(0,i.kt)("td",{parentName:"tr",align:null},"LR")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Conditional AND"),(0,i.kt)("td",{parentName:"tr",align:null},"&&"),(0,i.kt)("td",{parentName:"tr",align:null},"LR")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Conditional OR"),(0,i.kt)("td",{parentName:"tr",align:null},"|","|"),(0,i.kt)("td",{parentName:"tr",align:null},"LR")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Ternary operators"),(0,i.kt)("td",{parentName:"tr",align:null},"boolean expression ? expression1 : expression2"),(0,i.kt)("td",{parentName:"tr",align:null},"Right-to-left")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Assignment operators"),(0,i.kt)("td",{parentName:"tr",align:null},"=, +=, -=, *=, /=, %=, &=, ^=, ","|","=, <<=, >>=, >>>="),(0,i.kt)("td",{parentName:"tr",align:null},"Right-to-left")))))),(0,i.kt)("h3",{id:"unary-operators"},"Unary Operators"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Requires exactly one operand to function."),(0,i.kt)("table",{parentName:"li"},(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Operator"),(0,i.kt)("th",{parentName:"tr",align:null},"Examples"),(0,i.kt)("th",{parentName:"tr",align:null},"Description"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Logical complement"),(0,i.kt)("td",{parentName:"tr",align:null},"!a"),(0,i.kt)("td",{parentName:"tr",align:null},"Inverts a boolean's logical value")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Bitwise complement"),(0,i.kt)("td",{parentName:"tr",align:null},"~b"),(0,i.kt)("td",{parentName:"tr",align:null},"Inverts all 0s and 1s in a number")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Plus"),(0,i.kt)("td",{parentName:"tr",align:null},"+c"),(0,i.kt)("td",{parentName:"tr",align:null},"Indicates a number is positive")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Negation or minus"),(0,i.kt)("td",{parentName:"tr",align:null},"-d"),(0,i.kt)("td",{parentName:"tr",align:null},"Indicates a literal number is negative or negates an expression")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Increment"),(0,i.kt)("td",{parentName:"tr",align:null},"++e f++"),(0,i.kt)("td",{parentName:"tr",align:null},"Increments a value by 1")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Decrement"),(0,i.kt)("td",{parentName:"tr",align:null},"--f h--"),(0,i.kt)("td",{parentName:"tr",align:null},"Decrements a value by 1"))))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Bitwise complement operator ( ~ )")," flips all 0s and 1s in a number. ")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Bitwise complement operator can apply only on byte, short, int, long, char.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"You can use the formula ",(0,i.kt)("inlineCode",{parentName:"p"},"bitwise complement = -1 * number value -1")," to calculate the result for bitwise complement operation."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"int a = 7;\nSystem.out.println(~a); // Print -8. Because -1 * 7 - 1 \n"))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Negation operator ( - )")," reverses the sign of numeric expression.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Negation operator can apply only on numeric expression.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Increment and decrement operators ( ++ -- )")," can apply only on numeric variable.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"The order on how Increment and decrement operators attached to the variable can change the behavior."),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"++x / --y"),": increase / decrease by 1 and return the ",(0,i.kt)("strong",{parentName:"li"},"new value"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"x++ / y--"),": increase / decrease by 1 but return the ",(0,i.kt)("strong",{parentName:"li"},"original value"),".")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"int a = 1;\nSystem.out.println(++a); // print 2\nSystem.out.println(a++); // print 2\nSystem.out.println(a); // print 3\n")))),(0,i.kt)("h3",{id:"binary-arithemtic-operators"},"Binary Arithemtic Operators"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Addition: ",(0,i.kt)("inlineCode",{parentName:"li"},"a + b")),(0,i.kt)("li",{parentName:"ol"},"Subtraction: ",(0,i.kt)("inlineCode",{parentName:"li"},"a - b")),(0,i.kt)("li",{parentName:"ol"},"Multiplication: ",(0,i.kt)("inlineCode",{parentName:"li"},"a * b")),(0,i.kt)("li",{parentName:"ol"},"Division: ",(0,i.kt)("inlineCode",{parentName:"li"},"a / b")),(0,i.kt)("li",{parentName:"ol"},"Modulus: ",(0,i.kt)("inlineCode",{parentName:"li"},"a % b")),(0,i.kt)("li",{parentName:"ol"},"Arithmetic operators can apply on all primitives, except boolean."),(0,i.kt)("li",{parentName:"ol"},"Addition operators ( + ) can apply on String for concatenation."),(0,i.kt)("li",{parentName:"ol"},"You can change the precedence by wrapping with ",(0,i.kt)("strong",{parentName:"li"},"parentheses"),"."),(0,i.kt)("li",{parentName:"ol"},"Parentheses should be applied in a ",(0,i.kt)("em",{parentName:"li"},"valid")," and ",(0,i.kt)("em",{parentName:"li"},"balanced")," manner.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"A new right parentheses match with a previous left parentheses"),(0,i.kt)("li",{parentName:"ul"},"Equal number of left and right parentheses"))),(0,i.kt)("li",{parentName:"ol"},"For ",(0,i.kt)("strong",{parentName:"li"},"integer")," values, ",(0,i.kt)("strong",{parentName:"li"},"division")," results in the ",(0,i.kt)("strong",{parentName:"li"},"floor value")," (value without anything after the decimal point) of the nearest integer that fulfills the operation.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"System.out.println(13 / 4); // Prints 3\n")))),(0,i.kt)("h3",{id:"numeric-promotion"},"Numeric Promotion"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Numeric Promotion rules",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"If two values have different data types, promote one of the values to the larger of the two data types.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"int a = 1;\nlong b = 2;\nvar c = a + b; // a will be promoted to long. c will be long.\n"))),(0,i.kt)("li",{parentName:"ul"},"If one is integral and the other is floating-point, promote the integral value to the floating-point value's data type.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"int a = 1;\nfloat b = 2.1f;\nvar c = a + b; // a will be promoted to float. c will be float.\n"))),(0,i.kt)("li",{parentName:"ul"},"Smaller data types, namely, byte, short, and char, are first promoted to int, even if neither of the operands is int. ",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"byte a = 1;\nshort b = 2;\nvar c = a + b; // a and b will be promoted to int. c will be int.\n")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Unary operators are ",(0,i.kt)("strong",{parentName:"li"},"excluded")," from this rule."))),(0,i.kt)("li",{parentName:"ul"},"Resulting value will have the same data type as its promoted operands."))),(0,i.kt)("li",{parentName:"ol"},"Be aware of the data type of variables, intermediate values, and resulting values")),(0,i.kt)("h3",{id:"assignment-operator"},"Assignment Operator"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Binary operator that assigns variable on the left side with the result of the equation on the right side."),(0,i.kt)("li",{parentName:"ol"},"Promotion rule and Casting will occur during assignment."),(0,i.kt)("li",{parentName:"ol"},"Automatically promote from smaller to larger data type.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"short a = 10;\nbyte b = 20;\nint c = a + b;\nlong d = a + b;\nfloat e = a + b;\ndouble f = a + b;\nSystem.out.println(c); // Print 30\nSystem.out.println(d); // Print 30\nSystem.out.println(e); // Print 30.0\nSystem.out.println(f); // Print 30.0\n"))),(0,i.kt)("li",{parentName:"ol"},"Compilation error occurs if you try to promote from larger to smaller data type without casting."),(0,i.kt)("li",{parentName:"ol"},"Casting is a unary operation."),(0,i.kt)("li",{parentName:"ol"},"Compiler automatically casts smaller types to larger ones."),(0,i.kt)("li",{parentName:"ol"},"Casting is required when converting to smaller data type."),(0,i.kt)("li",{parentName:"ol"},"Casting is performed by placing the data type, enclosed in parentheses, to the left of the value you want to cast.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"short a = (short) 10;\nfloat b = 10;\nfloat c = (float) 10.0;\nfloat d = 10.0f;\n// This will error\nfloat e = 10.0;\n"))),(0,i.kt)("li",{parentName:"ol"},"Casting can also be applied to object and reference."),(0,i.kt)("li",{parentName:"ol"},"No conversion is performed for casting of object / reference."),(0,i.kt)("li",{parentName:"ol"},"Casting an object only change the reference of the object, not the object itself."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Overflow")," is when a number is so large that it will no longer fit within the data type, so the system \u201cwraps around\u201d to the lowest negative value and counts up from there.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"int a = (byte)( Byte.MAX_VALUE + 1 );\nSystem.out.println(a); // Print -128\n"))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Underflow")," is analogy to overflow when the number is too low to fit in the data type.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"int a = (byte)( Byte.MIN_VALUE - 1 );\nSystem.out.println(a); // Print 127\n"))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Casting")," can appear anywhere in an expression, not just an assignment."),(0,i.kt)("li",{parentName:"ol"},"Compiler ",(0,i.kt)("strong",{parentName:"li"},"doesn't require casting when working with literals")," that fit into data types.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"byte a = 1;\n// This will error\nbyte b = (byte) a * 2; // Because a is involved in the multiplication, third promotion rule applys, and a is casted to int during multiplication.\n# highlight-next-line\nbyte c = 10 * 2; // Doesn't require casting\n// This will error\nbyte d = 100 * 200; // Overflow occurs and compilers report error\n// This will error\nint e = 2 * 5.0;\n// This will error\nfloat f = 2 * 5.0;\n# highlight-next-line\nfloat g = 2 * 5.0f;\n# highlight-next-line\ndouble h = 2 * 5.0;\n"))),(0,i.kt)("li",{parentName:"ol"},"When working with ",(0,i.kt)("strong",{parentName:"li"},"literals / value"),", the compiler has enough information for the programmer's intent."),(0,i.kt)("li",{parentName:"ol"},"When working with ",(0,i.kt)("strong",{parentName:"li"},"variables"),", there is ambiguity about how to proceed, and the compilers will throw error."),(0,i.kt)("li",{parentName:"ol"},"Result of assignment for the expression is equal to the value of the assignment.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"int a = 5;\nint b = ( a = 10 ); // First 10 is assigned to a. Then the whole expression a = 10 returns 10.\nSystem.out.println(a); // Print 10\nSystem.out.println(b); // Print 10\n")))),(0,i.kt)("h3",{id:"compound-assignment-operators"},"Compound Assignment Operators"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Addition assignment: a += 10"),(0,i.kt)("li",{parentName:"ol"},"Subtraction assignment: b -= 10"),(0,i.kt)("li",{parentName:"ol"},"Multiplication assignment: c *= 10"),(0,i.kt)("li",{parentName:"ol"},"Division assignment: d /= 10"),(0,i.kt)("li",{parentName:"ol"},"Compound assignment is a glorified form of simple assignment. It performs the following:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"built-in operation that applies the left and right side of statement."),(0,i.kt)("li",{parentName:"ul"},"assigns the resulting value on the left side variable."),(0,i.kt)("li",{parentName:"ul"},"compiler will automatically perform casting during assignment.")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"    int a = 10;\n    long b = 100;\n    // This will error\n    a = a * b; // Compilation error as long type is assigned to int type\n    // This will error\n    a = (int) a * b; // Compilation error as casting applied to a only, and then promotes to long again during multiplication\n    # highlight-next-line\n    a = (int) (a * b); // Implicit casting from long to int\n    # highlight-next-line\n    a *= b; // Implicit casting from long to int\n")))),(0,i.kt)("h3",{id:"equality-operators"},"Equality Operators"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Equality ",(0,i.kt)("inlineCode",{parentName:"li"},"==")," and Inequality ",(0,i.kt)("inlineCode",{parentName:"li"},"!="),"."),(0,i.kt)("li",{parentName:"ol"},"For object type, we need to distinguish if",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"2 objects are the same. (Using equality operator)"),(0,i.kt)("li",{parentName:"ul"},"2 objects are equivalent. (Using equals method)"))),(0,i.kt)("li",{parentName:"ol"},"For object comparison, equality operator is applied to reference, not to the object that reference point to."),(0,i.kt)("li",{parentName:"ol"},"For primitive type, there is no such distinction."),(0,i.kt)("li",{parentName:"ol"},"Equality Operators must apply on the same type.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'int a = 1;\nfloat b = 2.0f;\nboolean c = true;\nString d = "true";\nint a1 = 1;\nfloat b1 = 3.0f;\nboolean c1 = true;\n# highlight-next-line\nSystem.out.println( a == b ); // Promotion rule to promote a to float\n// This will error\nSystem.out.println( b == c ); // Compilation error due to comparison between mixed type\n// This will error\nSystem.out.println( c == d ); // Compilation error due to comparison between mixed type\n# highlight-next-line\nSystem.out.println( a == a1 );\n# highlight-next-line\nSystem.out.println( b == b1 );\n# highlight-next-line\nSystem.out.println( c == c1 );\n'))),(0,i.kt)("li",{parentName:"ol"},"Comparing null with null will return true in java.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"System.out.println( null == null ); // Print true\n")))),(0,i.kt)("h3",{id:"relational-operators"},"Relational Operators"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},">"),", ",(0,i.kt)("inlineCode",{parentName:"li"},">="),", ",(0,i.kt)("inlineCode",{parentName:"li"},"<"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"<="),", ",(0,i.kt)("inlineCode",{parentName:"li"},"instanceof")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"instanceof")," tests whether the target object is a member of a particular class or interface at runtime."),(0,i.kt)("li",{parentName:"ol"},"If the compiler can determine that a variable cannot possibly be cast to a specific class, it reports an error.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"Integer x = 1;\n// This will error\nif(x instanceof String){\n    // Do something\n}\n"))),(0,i.kt)("li",{parentName:"ol"},"instanceof on a null literal / reference will always return false.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'String a = null;\nString b = "Hello World";\nSystem.out.println( null instanceof Object ); // Print false\nSystem.out.println( a instanceof String ); // Print false\nSystem.out.println( b instanceof Object ); // Print true\nSystem.out.println( b instanceof String ); // Print true\n'))),(0,i.kt)("li",{parentName:"ol"},"null cannot be used on the right side of instanceof.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"String a = null;\n// This will error\nSystem.out.println( a instanceof null );\n")))),(0,i.kt)("h3",{id:"logical-operator"},"Logical Operator"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Logical AND ",(0,i.kt)("inlineCode",{parentName:"li"},"&"),": true when both operands are true."),(0,i.kt)("li",{parentName:"ol"},"Logical OR ",(0,i.kt)("inlineCode",{parentName:"li"},"|"),": true when at least one of operands is true."),(0,i.kt)("li",{parentName:"ol"},"Logical XOR ",(0,i.kt)("inlineCode",{parentName:"li"},"^"),": true when operands are different to each other.")),(0,i.kt)("h3",{id:"conditional-operator"},"Conditional Operator"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Conditional AND ",(0,i.kt)("inlineCode",{parentName:"li"},"&&"),": true when both operands are true."),(0,i.kt)("li",{parentName:"ol"},"Conditional OR ",(0,i.kt)("inlineCode",{parentName:"li"},"||"),": true when at least one of operands is true."),(0,i.kt)("li",{parentName:"ol"},"Short-circuit",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"For &&, if left side is false, right side will not be evaluated."),(0,i.kt)("li",{parentName:"ul"},"For ||, if left side is true, right side will not be evaluated."))),(0,i.kt)("li",{parentName:"ol"},"Avoid null pointer exception.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'String a = null;\nif( a != null && a.equals("Hello World")){ // Since a is null, if will short circuit immediately, and avoid NullPointerException on the right side\n}\n// This will error\nif( a != null & a.equals("Hello World")){ // Throw NullPointerException at runtime\n}\n')))),(0,i.kt)("h3",{id:"ternary-operator"},"Ternary Operator"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"(boolean expression) ? ( expression that returned if boolean is true) : ( expression that returned if boolean is false)"),(0,i.kt)("li",{parentName:"ol"},"Second and third expressions in ternary operations don't need to be the same data type.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"int a = 5;\nlong b = 10;\nint c = (int)((true) ? b : a);\nSystem.out.println(c); // Print 10\n"))),(0,i.kt)("li",{parentName:"ol"},"Second and third expressions must make sense for the data type. Compiler can detect wrong data type.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'int a = 5;\n// This will error\nint c = (int)((false) ? "Hello" : a);\n'))),(0,i.kt)("li",{parentName:"ol"},"Only one of the expression on the right will be evaluated at runtime. Beware of ",(0,i.kt)("strong",{parentName:"li"},"unperformed side effect"),".")),(0,i.kt)("h2",{id:"control-flow-statement"},"Control Flow Statement"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("em",{parentName:"li"},"Control Flow Statement")," breaks up the flow of execution by",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Decision making (",(0,i.kt)("em",{parentName:"li"},"if"),", ",(0,i.kt)("em",{parentName:"li"},"switch"),")"),(0,i.kt)("li",{parentName:"ul"},"Looping (",(0,i.kt)("em",{parentName:"li"},"while"),", ",(0,i.kt)("em",{parentName:"li"},"do/while"),", ",(0,i.kt)("em",{parentName:"li"},"for"),", ",(0,i.kt)("em",{parentName:"li"},"for-each"),")"),(0,i.kt)("li",{parentName:"ul"},"Branching (",(0,i.kt)("em",{parentName:"li"},"Nested loop"),", ",(0,i.kt)("em",{parentName:"li"},"continue"),", ",(0,i.kt)("em",{parentName:"li"},"break"),", ",(0,i.kt)("em",{parentName:"li"},"return"),")"))),(0,i.kt)("li",{parentName:"ol"},"It allows selective execution for a particular segments of code."),(0,i.kt)("li",{parentName:"ol"},"Target can be a single statement or block of statements."),(0,i.kt)("li",{parentName:"ol"},"Using block is often preferred.")),(0,i.kt)("h3",{id:"if-statement"},(0,i.kt)("em",{parentName:"h3"},"if")," statement"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Java only accepts boolean expression, unlike other languages that accept 0 or 1."),(0,i.kt)("li",{parentName:"ol"},"Remember to trace the open and close braces of a block.")),(0,i.kt)("h4",{id:"pattern-matching-java-14"},"Pattern matching (Java 14)"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Java 16 introduces ",(0,i.kt)("strong",{parentName:"li"},"pattern matching")," for if statement using ",(0,i.kt)("inlineCode",{parentName:"li"},"instanceof")," operator.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java",metastring:"title='if statement'",title:"'if","statement'":!0},"if(baobao instanceof Dog){\n    Dog dog = (Dog) baobao;\n    dog.bark();\n}\n")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java",metastring:"title='if statement (With pattern matching)'",title:"'if",statement:!0,"(With":!0,pattern:!0,"matching)'":!0},"if(baobao instanceof Dog dog ){\n    dog.bark();\n}\n"))),(0,i.kt)("li",{parentName:"ol"},"Unrelated to regular expression."),(0,i.kt)("li",{parentName:"ol"},"Enhancement to reduce boilerplate code by introducing implicit type casting."),(0,i.kt)("li",{parentName:"ol"},"From the above example, ",(0,i.kt)("em",{parentName:"li"},"dog")," is the ",(0,i.kt)("strong",{parentName:"li"},"pattern variable"),". "),(0,i.kt)("li",{parentName:"ol"},"Avoid potential ClassCastException because type casting is performed only if the instanceof statement is true."),(0,i.kt)("li",{parentName:"ol"},"It is a bad practice to reassign the pattern variable. Prevent reassignment by ",(0,i.kt)("inlineCode",{parentName:"li"},"final")," modifier.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"if(baobao instanceof Dog dog ){\n    dog = new SmallDog(); // Bad practice to reassign the pattern variable.\n}\n")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"if(baobao instanceof final Dog dog ){ // Prevent reassignment by final modifier\n    // Do something\n}\n"))),(0,i.kt)("li",{parentName:"ol"},"We can include && statement with pattern variable that declared on the same line to filter data out.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"if(baobao instanceof final Dog dog \n# highlight-next-line\n    && dog.getAge() > 10 ){\n    // Do something\n}\n"))),(0,i.kt)("li",{parentName:"ol"},"Pattern variable must be a strict subtype. It ",(0,i.kt)("strong",{parentName:"li"},"cannot even")," be the ",(0,i.kt)("strong",{parentName:"li"},"same")," type.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"Integer a = 1000;\n// This will error\nif(a instanceof Integer b){\n    // Do something\n}\n"))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Flow scoping")," means the variable is in scope only when the compiler can definitely determine its type."),(0,i.kt)("li",{parentName:"ol"},"Not strictly hierarchical like instance, class or local scoping."),(0,i.kt)("li",{parentName:"ol"},"Even if the variable is not inside the if statement, it can still be deemed in scope by the compiler.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"void test(Number number) { \n    if (!(number instanceof Integer data))\n        return;\n    # highlight-next-line    \n    System.out.println(data.intValue()); // Compiler determines the data variable in this line is in scope\n}\n")),"Here, the ",(0,i.kt)("em",{parentName:"li"},"System.out.println")," statement is not within if statement. However the compiler determines it is in scope as the instanceof operator returns true for that area."),(0,i.kt)("li",{parentName:"ol"},"We can conclude pattern matching is quite different from other scoping. It is not determined hierarchically by a pair of braces. It is determined by the compiler.")),(0,i.kt)("h3",{id:"switch-statement"},(0,i.kt)("em",{parentName:"h3"},"switch")," statement"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"If no such case is found, the default case will be called. If default case is not provided, the whole switch block will be simply skipped.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'int a = 999;\nswitch(a){\n    case 1: \n        System.out.println("1");\n        break;    \n    default: \n        System.out.println("0");\n        break;\n}\n')),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-txt",metastring:'title="Result"',title:'"Result"'},"0\n"))),(0,i.kt)("li",{parentName:"ol"},"A break statement ends the switch statement immediately.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'int a = 3;\nswitch(a){\n    case 1: \n        System.out.println("1");\n        break;\n    case 2: \n        System.out.println("2");\n        break;    \n    case 3: \n        System.out.println("3");\n        break;\n    default: \n        System.out.println("0");\n        break;\n}\n')),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-txt",metastring:'title="Result"',title:'"Result"'},"3\n"))),(0,i.kt)("li",{parentName:"ol"},"Without break statement, it will match the first case statement, and ",(0,i.kt)("strong",{parentName:"li"},"executes all of the branches")," in the order they are found.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'int a = 3;\nswitch(a){\n    case 1: System.out.println("1");\n    case 2: System.out.println("2");    \n    case 3: System.out.println("3");\n    default: System.out.println("0");  \n    case 5: System.out.println("5");  \n    case 4: System.out.println("4");  \n}\n')),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-txt",metastring:'title="Result"',title:'"Result"'},"3\n0\n5\n4\n"))),(0,i.kt)("li",{parentName:"ol"},"Starting with Java 14, case value can be combined.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="Prior to Java 14"',title:'"Prior',to:!0,Java:!0,'14"':!0},'int a = 2;\nswitch(a){\n    # highlight-next-line\n    case 1: case 2: \n        System.out.println(" 1 or 2 ");\n        break;\n    case 3: \n        System.out.println(" 3 ");\n        break;\n    default: \n        System.out.println(" Default ");\n        break;\n}\n')),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java",metastring:'title="Starting with Java 14"',title:'"Starting',with:!0,Java:!0,'14"':!0},'int a = 2;\nswitch(a){\n    # highlight-next-line\n    case 1, 2: \n        System.out.println(" 1 or 2 ");\n        break;\n    case 3: \n        System.out.println(" 3 ");\n        break;\n    default: \n        System.out.println(" Default ");\n        break;\n}\n'))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("em",{parentName:"li"},"switch")," supports the following data type.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"byte, short, int"),(0,i.kt)("li",{parentName:"ul"},"char, String"),(0,i.kt)("li",{parentName:"ul"},"enum values"))),(0,i.kt)("li",{parentName:"ol"},"boolean, long, float, double are not supported because their range of values are either too narrow or wide."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("em",{parentName:"li"},"case")," value must be ",(0,i.kt)("strong",{parentName:"li"},"compile time constant expression"),". If the case value cannot be evaluated until runtime, it will fail the compilation.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'static int getValue(){\n    return 2;\n}\npublic static void main(String... args) {\n    int a = 2;\n    final int CASE_1 = 1;\n    final int CASE_2 = getValue();\n    switch(a){\n        # highlight-next-line\n        case CASE_1:\n            System.out.println(" 1 ");\n            break;\n        // This will error\n        case CASE_2:\n            System.out.println(" 2 ");\n            break;\n        default:\n            System.out.println(" Default ");\n            break;\n    }\n}\n'))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("em",{parentName:"li"},"case")," value supports only",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"literals"),(0,i.kt)("li",{parentName:"ul"},"enum constants"),(0,i.kt)("li",{parentName:"ul"},"final constants")))),(0,i.kt)("h4",{id:"switch-expression-java-14"},(0,i.kt)("em",{parentName:"h4"},"switch")," expression (Java 14)"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Starting with Java 14, ",(0,i.kt)("strong",{parentName:"li"},"switch expression")," is supported.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"byte a = 2;\nbyte b = 4;\nbyte c = switch (a) {\n    case 1 -> 0; // expression\n    case 2, 3 -> { // block\n        if (b == 4) {\n            yield 10;\n        } else {\n            yield 20;\n        }\n    }\n    default -> 99;\n};\nSystem.out.println(c);\n")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-txt",metastring:'title="Result"',title:'"Result"'},"10\n"))),(0,i.kt)("li",{parentName:"ol"},"It is a compact form of switch statement."),(0,i.kt)("li",{parentName:"ol"},"It can return a value."),(0,i.kt)("li",{parentName:"ol"},"It supports both ",(0,i.kt)("em",{parentName:"li"},"expression")," and ",(0,i.kt)("em",{parentName:"li"},"block"),"."),(0,i.kt)("li",{parentName:"ol"},"Keyword ",(0,i.kt)("inlineCode",{parentName:"li"},"yield")," (exit the block) is provided to distinguish it from the keyword ",(0,i.kt)("inlineCode",{parentName:"li"},"return")," (exit the method)."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("em",{parentName:"li"},"break")," statement is not required. Only one branch will be executed."),(0,i.kt)("li",{parentName:"ol"},"Each case or default expression requires a semicolon as well as the assignment itself."),(0,i.kt)("li",{parentName:"ol"},"It is allowed that switch expression doesn't return a value.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'byte a = 3;\nswitch(a){\n    case 1 -> System.out.println("1");\n    case 2 -> System.out.println("2");\n    case 3 -> System.out.println("3");\n    default -> System.out.println("default"); // Default case is optional in this case\n}\n'))),(0,i.kt)("li",{parentName:"ol"},"If the switch expression returns value, all of the branches must either ",(0,i.kt)("strong",{parentName:"li"},"return")," a value (expression) or ",(0,i.kt)("strong",{parentName:"li"},"yield")," a value (block)."),(0,i.kt)("li",{parentName:"ol"},"If the switch expression returns value, all possible case values have to be covered. You can either",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"provide a default branch."),(0,i.kt)("li",{parentName:"ul"},"or cover all possible values. Though quite impossible unless it is a enum type."))),(0,i.kt)("li",{parentName:"ol"},"If the switch expression returns value, all case and default branches must return a ",(0,i.kt)("strong",{parentName:"li"},"consistent")," and ",(0,i.kt)("strong",{parentName:"li"},"compatible")," data type.")),(0,i.kt)("h3",{id:"while-statement"},(0,i.kt)("em",{parentName:"h3"},"while")," statement"),(0,i.kt)("h3",{id:"do-while-statement"},(0,i.kt)("em",{parentName:"h3"},"do while")," statement"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Guarantee the statement or block inside will be run once.")),(0,i.kt)("h3",{id:"for-loop"},(0,i.kt)("em",{parentName:"h3"},"for")," loop"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Infinite loop is allowed."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'for(;;){\n    System.out.println("Hello World.");\n    break;\n}\n'))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Multiple variables are allowed."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'for(int x=0 , y=10; x<20 || y>=0; x++, y--){\n    System.out.println("x="+x);\n    System.out.println("y="+y);\n}\n'))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Variables must all be of the same type and declared once."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'// This will error\nfor(int x=0 , long y=10; x<20 || y>=0; x++, y--){\n    System.out.println("x="+x);\n    System.out.println("y="+y);\n}\n\n// This will error\nfor(int x=0 , int y=10; x<20 || y>=0; x++, y--){\n    System.out.println("x="+x);\n    System.out.println("y="+y);\n}\n'))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Using variable outside the loop is not allowed. The variable is only scoped for the loop."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'for(int x=0 , y=10; x<20 || y>=0; x++, y--)\n    System.out.println("x="+x);\n// This will error\nSystem.out.println("y="+y);\n')))),(0,i.kt)("h3",{id:"for-each-loop"},(0,i.kt)("em",{parentName:"h3"},"for each")," loop"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"The right side must be:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"built-in Java array."),(0,i.kt)("li",{parentName:"ul"},"an object that implements ",(0,i.kt)("em",{parentName:"li"},"java.lang.Iterable"),"."))),(0,i.kt)("li",{parentName:"ol"},"Not all Collection Framework classes implements ",(0,i.kt)("em",{parentName:"li"},"java.lang.Iterable"),"."),(0,i.kt)("li",{parentName:"ol"},"Map does not implement ",(0,i.kt)("em",{parentName:"li"},"java.lang.Iterable"),". However, the collection that its methods such as values() and keySet() returns does.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'Map<String, Integer> map = new HashMap<String, Integer>();\nmap.put("one", 1);\nmap.put("two", 2);\n# highlight-next-line\nfor(String key: map.keySet()){\n    System.out.println(key);\n}\n# highlight-next-line\nfor(Integer value: map.values()){\n    System.out.println(value);\n}\n')))),(0,i.kt)("h3",{id:"branching"},"Branching"),(0,i.kt)("h4",{id:"nested-loop"},"Nested Loop"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"A loop can contain another loop. This is called nested loop.")),(0,i.kt)("h4",{id:"optional-label"},"Optional label"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("em",{parentName:"li"},"if"),", ",(0,i.kt)("em",{parentName:"li"},"switch")," and ",(0,i.kt)("em",{parentName:"li"},"for")," loop can all have ",(0,i.kt)("strong",{parentName:"li"},"optional labels")," on their block and control statements."),(0,i.kt)("li",{parentName:"ol"},"Optional label is not good for readability. Use only when necessary.")),(0,i.kt)("h4",{id:"break-statement"},(0,i.kt)("em",{parentName:"h4"},"break")," statement"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Break statement breaks the loop early. The loop terminates immediately. There will be no further iteration."),(0,i.kt)("li",{parentName:"ol"},"For nested loops, without a label, the break statement will terminate the latest inner loop.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"for(int i=0 ; i<10; i++){\n    for(int j=0 ; j<10; j++){\n        System.out.println( i + j );\n        if (i==j)\n        # highlight-next-line\n            break;\n    }\n}\n"))),(0,i.kt)("li",{parentName:"ol"},"For nested loops, with an optional label, it makes the break statement possible to break out a higher level outer loop.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"OUTER_LOOP: for(int i=0 ; i<10; i++){\n    INNER_LOOP: for(int j=0 ; j<10; j++){\n        System.out.println( i + j );\n        if (i==j)\n        # highlight-next-line\n            break OUTER_LOOP;\n    }\n}\n")))),(0,i.kt)("h4",{id:"continue-statement"},(0,i.kt)("em",{parentName:"h4"},"continue")," statement"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Continue statement ends the current iteration of the loop. It will skip the current iteration of the loop. It will continue to run the remaining iterations of the loop."),(0,i.kt)("li",{parentName:"ol"},"For nested lopps, without a label, the continue statement will end the current iteration of the inner loop."),(0,i.kt)("li",{parentName:"ol"},"For nested loops, with an optional label, the continue statement can end the current iteration of higher level outer loop.")),(0,i.kt)("h4",{id:"return-statement"},(0,i.kt)("em",{parentName:"h4"},"return")," statement"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"When the loop is inside a method, return statement can be used to exit the loop early, instead of using break statement with optional label.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"for(int i=0 ; i<10; i++){\n    for(int j=0 ; j<10; j++){\n        System.out.println( i + j );\n        if (i==j)\n        # highlight-next-line\n            return;\n    }\n}\n"))),(0,i.kt)("li",{parentName:"ol"},"Code without break statements and labels are easier to read.")),(0,i.kt)("h4",{id:"unreachable-code"},"Unreachable Code"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Any code placed immediately after ",(0,i.kt)("em",{parentName:"li"},"break"),", ",(0,i.kt)("em",{parentName:"li"},"continue"),", ",(0,i.kt)("em",{parentName:"li"},"return")," will be deemed unreachable by compiler.")),(0,i.kt)("h4",{id:"support-for-labels-break-continue-and-yield"},"Support for labels, ",(0,i.kt)("inlineCode",{parentName:"h4"},"break"),", ",(0,i.kt)("inlineCode",{parentName:"h4"},"continue")," and ",(0,i.kt)("inlineCode",{parentName:"h4"},"yield")),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"yield")," can only be used in switch expression."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"continue")," can only be used in loop statement."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"break")," and optional labels can be used in switch and loop statements.")),(0,i.kt)("h2",{id:"core-apis"},"Core APIs"),(0,i.kt)("h3",{id:"string"},"String"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"A sequence of characters which counts from 0 when indexed."),(0,i.kt)("li",{parentName:"ol"},"Doesn't need to be instantiated with new."),(0,i.kt)("li",{parentName:"ol"},"Text block can create String.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'String hello = """\n                Hello World""";\n'))),(0,i.kt)("li",{parentName:"ol"},"Implements the interface ",(0,i.kt)("inlineCode",{parentName:"li"},"CharSequence"),"."),(0,i.kt)("li",{parentName:"ol"},"Rules for + operator",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"When both operands are numeric, + means addition."),(0,i.kt)("li",{parentName:"ul"},"If either one is String, + means concatenation."),(0,i.kt)("li",{parentName:"ul"},"Expression is evaluated from left to right."),(0,i.kt)("li",{parentName:"ul"},"During concatenation, a null value will be represented by the string ",(0,i.kt)("strong",{parentName:"li"},"null"),".")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'System.out.println( 10 + 100 ); // 110\nSystem.out.println( 12 + "345" ); // 12345\nSystem.out.println( "543" + 12 ); // 54321\nSystem.out.println( "654" + 32 + 1 ); // 654321\nSystem.out.println( 12 + 3 + "456" ); // 15456 \n// This will error\nSystem.out.println( 1 + null ); // compile error\nSystem.out.println( "1" + null ); // 1null\nString a = null;\nString b = null;\nSystem.out.println( a + b ); // nullnull\n'))),(0,i.kt)("li",{parentName:"ol"},'a += "1" means a = a + "1".'),(0,i.kt)("li",{parentName:"ol"},"String is immutable."),(0,i.kt)("li",{parentName:"ol"},"Calling a method on String will return a different String object."),(0,i.kt)("li",{parentName:"ol"},"Illustration of String method.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'String stringA = "Hello World";\n// length\nSystem.out.println( stringA.length() ); // 11\n// charAt\nSystem.out.println( stringA.charAt(0) ); // H\nSystem.out.println( stringA.charAt(10) ); // d\ntry{\n    // This will error\n    System.out.println( stringA.charAt(11) ); // Runtime error: java.lang.StringIndexOutOfBoundsException\n}\ncatch (Exception e){\n    System.out.println(e);\n}\n// indexOf\nSystem.out.println( stringA.indexOf(\'l\') ); // 2\nSystem.out.println( stringA.indexOf("l") ); // 2\n// subString\nSystem.out.println( stringA.substring(6) ); // World\nSystem.out.println( stringA.substring(0,2) ); // He\n// toLowerCase, toUpperCase\nSystem.out.println( stringA.toLowerCase() ); // hello world\nSystem.out.println( stringA.toUpperCase() ); // HELLO WORLD\n// equals, equalIgnoreCase\nSystem.out.println( stringA.toLowerCase().equals(stringA) ); // false\nSystem.out.println( stringA.toLowerCase().equalsIgnoreCase(stringA.toUpperCase()) ); // true\n// startsWith, endsWith, contains\nSystem.out.println( stringA.startsWith("Hello")); // true\nSystem.out.println( stringA.endsWith("World")); // true\nSystem.out.println( stringA.contains("o W")); // true\n// replace\nSystem.out.println( stringA.replace(\'H\', \'h\').replace(\'W\',\'w\')); // hello world\nSystem.out.println( stringA.replace("Hello", "Happy")); // Happy World\n// isEmpty, isBlank\nSystem.out.println(" ".isEmpty()); // false\nSystem.out.println("".isEmpty());  // true\nSystem.out.println(" ".isBlank()); // true\nSystem.out.println("".isBlank());  // true\n// trim, strip, stripLeading, stripTrailing\nSystem.out.println( "  Hello World   ".trim()); // "Hello World"\nSystem.out.println( "  Hello World   ".strip()); // "Hello World"\nSystem.out.println( "  Hello World   ".stripLeading()); // "Hello World   "\nSystem.out.println( "  Hello World   ".stripTrailing()); // "   Hello World"\n')),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java",metastring:"title='Run to see the indentation'",title:"'Run",to:!0,see:!0,the:!0,"indentation'":!0},'// indent\nvar stringX = """\n                Hello\n                 World""";\nSystem.out.println(stringX);\nSystem.out.println(stringX.length()); // 12\nSystem.out.println(stringX.indent(0));\nSystem.out.println(stringX.indent(0).length()); // 13\nSystem.out.println(stringX.indent(1));\nSystem.out.println(stringX.indent(1).length()); // 15\nSystem.out.println(stringX.indent(-1));\nSystem.out.println(stringX.indent(-1).length()); // 12\n')),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java",metastring:"title='Run to see the indentation'",title:"'Run",to:!0,see:!0,the:!0,"indentation'":!0},'// stripIndent\nvar stringY = " Hello\\n" +\n              " World\\n" +\n              " !";\nSystem.out.println(stringY);\nSystem.out.println(stringY.length()); // 16\nSystem.out.println(stringY.stripIndent());\nSystem.out.println(stringY.stripIndent().length()); // 13\n')),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'// translateEscapes\nvar stringA = " Hello\\\\n" +\n              " World\\\\n" +\n              " !";\nSystem.out.println(stringA);\nSystem.out.println(stringA.translateEscapes());\n')),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-txt",metastring:"title='Result'",title:"'Result'"},"Hello\\n World\\n !\nHello\nWorld\n!\n")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'// format, formatted\nvar stringA = "Hello World";\nvar integerB = 123;\nvar doubleC = 456.0;\nSystem.out.println( String.format("%s%n integerB=%d%n doubleC=%f", stringA, integerB, doubleC));\nSystem.out.println( "%s%n integerB=%d%n doubleC=%f".formatted( stringA, integerB, doubleC));\n')),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-txt",metastring:"title='Result'",title:"'Result'"},"Hello World\n integerB=123\n doubleC=456.000000\nHello World\n integerB=123\n doubleC=456.000000     \n")))),(0,i.kt)("h3",{id:"stringbuilder"},"StringBuilder"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"StringBuilder is not immutable."),(0,i.kt)("li",{parentName:"ol"},"Concatenation of String will result in a lot of interim String objects, which are immediately available for GC.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",27:!0,className:"language-java",metastring:"title='Below code will create 27 objects.'",title:"'Below",code:!0,will:!0,create:!0,"objects.'":!0},"String str = \"\";\nfor(char i='a'; i<='z'; i++)\n    str += i;\nSystem.out.println(str);\n"))),(0,i.kt)("li",{parentName:"ol"},"Concatenation of String via StringBuilder will not result in any interim object.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java",metastring:"title='Below code will create only the StringBuilder object.'",title:"'Below",code:!0,will:!0,create:!0,only:!0,the:!0,StringBuilder:!0,"object.'":!0},"StringBuilder stringBuilder = new StringBuilder(\"\");\nfor(char i='a'; i<='z'; i++)\n    stringBuilder.append(i);\nSystem.out.println(stringBuilder.toString());\n"))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"substring()")," returns a String instead of StringBuilder. No modification is ever made to the original StringBuilder.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'// substring\nStringBuilder stringBuilder = new StringBuilder("Hello World");\nString substring = stringBuilder.substring(0,4);\nSystem.out.println(substring); // Hell\nSystem.out.println(stringBuilder.toString()); // Hello World\n'))),(0,i.kt)("li",{parentName:"ol"},"Some common methods as below:",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'var stringBuilder = new StringBuilder("Hello World");\n// length\nSystem.out.println(stringBuilder.length()); // 11\n// indexOf\nSystem.out.println(stringBuilder.indexOf("l")); // 2\n// charAt\nSystem.out.println(stringBuilder.charAt(4)); // o\n// insert, append\nSystem.out.println(stringBuilder.insert(0,\'(\').append(\')\')); // (Hello World)\n// delete, deleteCharAt\nSystem.out.println(stringBuilder.delete(0,1).deleteCharAt(stringBuilder.length()-1)); // Hello World\n// replace\nSystem.out.println(stringBuilder.replace(0,5,"Happy")); // Happy World\n// reverse, toString\nSystem.out.println(stringBuilder.reverse().toString().toUpperCase()); // DLROW YPPAH\n')))),(0,i.kt)("h3",{id:"equality"},"Equality"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Operator ",(0,i.kt)("inlineCode",{parentName:"li"},"==")," checks object reference equality."),(0,i.kt)("li",{parentName:"ol"},"By default, ",(0,i.kt)("inlineCode",{parentName:"li"},"equals()")," checks object reference equality."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"equals()")," of StringBuilder checks object reference equality.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'var a1 = new StringBuilder("Hello World");\nvar a2 = new StringBuilder("Hello World");\nSystem.out.println(a1.equals(a2)); // false\nSystem.out.println(a1 == a2); // false\n'))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"equals()")," of String is overridden, and checks value equality.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'var a1 = "Hello World";\nvar a2 = "Hello World";\nSystem.out.println(a1.equals(a2)); // true\nSystem.out.println(a1 == a2); // true\n'))),(0,i.kt)("li",{parentName:"ol"},"String literal is pooled in String Pool.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'var a1 = "Hello World";\nvar a2 = "Hello World";\nvar a3 = "Hello" + " " + "World";\nvar a4 = "Hello World".trim();\nvar a5 = " Hello World ".trim();\nSystem.out.println(a1 == a2); // true\nSystem.out.println(a1 == a3); // true\nSystem.out.println(a1 == a4); // true\nSystem.out.println(a1 == a5); // false\n'))),(0,i.kt)("li",{parentName:"ol"},"For String that are not the same at compile time, a new String object is created.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'var a1 = "Hello World";\nvar a2 = "Hello";\na2 += " World";\nSystem.out.println(a1 == a2); // false\n'))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"intern()")," will return the String from the String Pool (if exist) instead of creating a new String.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'var a1 = "Hello World";\nvar a2 = "Hello";\na2 += " World";\na2 = a2.intern();\nSystem.out.println(a1 == a2); // true\n'))),(0,i.kt)("li",{parentName:"ol"},"intern() should only be used in the exam.")),(0,i.kt)("h3",{id:"array"},"Array"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"An area of memory on the heap with space for a designated number of elements."),(0,i.kt)("li",{parentName:"ol"},"Both String and StringBuilder are implemented as array."),(0,i.kt)("li",{parentName:"ol"},"For String, method is provided to handle characters specifically."),(0,i.kt)("li",{parentName:"ol"},"For StringBuilder, array object is replaced with bigger array object when running out of space."),(0,i.kt)("li",{parentName:"ol"},"An array is an ordered list."),(0,i.kt)("li",{parentName:"ol"},"Declaration",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"int[] a1;\nint [] a2;\nint []a3;\nint a4[];\nint a5 [];\n// Multiple declaration\nint[] a6, a7; // 2 int array\nint a8, a9[] // 1 int, 1 int[]\n"))),(0,i.kt)("li",{parentName:"ol"},"Instantiation and initialization",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"int[] a = new int[] { 1, 2, 3};\nint[] b = { 1, 2, 3 };\n"))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"equals()")," of array checks reference equality.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"Integer[] a = { 1, 2, 3 };\nInteger[] b = a;\nSystem.out.println(a.equals(b)); // true\nSystem.out.println(a); // [Ljava.lang.Integer;@7a4f0f29\n// [L means array.\n// java.lang.Integer is the reference type.\n// 7a4f0f29 is the hash code\nSystem.out.println(Arrays.toString(a)); // [1, 2, 3]\n"))),(0,i.kt)("li",{parentName:"ol"},"Casting to force bigger type to smaller type.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'String[] strings1 = { "Happy Valley" };\nObject[] objects = strings1;\nString[] strings2 = (String[]) objects;\n// This will error\nobjects[0] = new StringBuilder("Hello World"); // java.lang.ArrayStoreException\n'))),(0,i.kt)("li",{parentName:"ol"},"Some common methods",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'String[] friends = { "Mary", "Cindy", "Amy"};\nSystem.out.println(friends.length); // 3\n// This will error\nSystem.out.println(friends.length()); // Compilation Error\nSystem.out.println(friends[0]); // Mary\n// This will error\nSystem.out.println(friends[3]); // ArrayIndexOutOfBoundsException\n'))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("em",{parentName:"li"},"length")," attribute does not consider what is in the array. It only considers how many slots have been allocated.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"String[] friends = new String[3];\nSystem.out.println(friends.length); // 3\nSystem.out.println(friends[0]); // null\n"))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"sort"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'String[] friends = { "Mary", "Cindy", "Amy"};\nSystem.out.println(Arrays.toString(friends)); // [Mary, Cindy, Amy]\nArrays.sort(friends);\nSystem.out.println(Arrays.toString(friends)); // [Amy, Cindy, Mary]\n'))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"binarySearch"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Prerequisite: the array should be sorted beforehand, or unknown result will be returned."),(0,i.kt)("li",{parentName:"ul"},"Found: return index."),(0,i.kt)("li",{parentName:"ul"},"Not Found:  -(Index of smaller but largest match) -1 .")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"int[] a = { 10, 50, 100, 1000, 10000};\nSystem.out.println(Arrays.binarySearch(a, 10)); // 0\nSystem.out.println(Arrays.binarySearch(a, 100)); // 2\nSystem.out.println(Arrays.binarySearch(a, 999)); // -4\nSystem.out.println(Arrays.binarySearch(a, 5000)); // -5\nSystem.out.println(Arrays.binarySearch(a, 9999)); // -5\n"))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"compare")," for number",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"same length, same elements => 0"),(0,i.kt)("li",{parentName:"ul"},"same elements, but more element at the end of first array => +"),(0,i.kt)("li",{parentName:"ul"},"same elements, but more element at the end of second array => -"),(0,i.kt)("li",{parentName:"ul"},"first element is larger in the first array => +"),(0,i.kt)("li",{parentName:"ul"},"first element is larger in the second array => -")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"int[] a1 = { 1, 3, 5, 7, 9};\nint[] a2 = { 1, 3, 5, 7, 9};\nint[] b1 = { 1, 3, 5, 7, 9, 11};\nint[] b2 = { 1, 3, 5, 7};\nint[] c1 = { 2, 2, 2, 2, 2};\nint[] c2 = { 1, 2, 2, 2, 2};\nint[] c3 = { 1, 4, 2, 2, 2};\nint[] c4 = { 1, 1, 1, 1};\nint[] c5 = { 1, 1, 1, 1, 1, 1};\nSystem.out.println(Arrays.compare(a1, a2)); // 0\nSystem.out.println(Arrays.compare(a1, b1)); // -1\nSystem.out.println(Arrays.compare(a1, b2)); // 1\nSystem.out.println(Arrays.compare(a1, c1)); // -1\nSystem.out.println(Arrays.compare(a1, c2)); // 1\nSystem.out.println(Arrays.compare(a1, c3)); // -1\nSystem.out.println(Arrays.compare(a1, c4)); // 1\nSystem.out.println(Arrays.compare(a1, c5)); // 1\n"))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"compare")," for string",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"null is smaller"),(0,i.kt)("li",{parentName:"ul"},"uppercase is smaller than lowercase"),(0,i.kt)("li",{parentName:"ul"},"number is smaller than letter")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'String[] a = { "a" };\nString[] A = { "A" };\nString[] b = { "b" };\nString[] B = { "B" };\nString[] c_s = { "c" , "C" };\nString[] z = { "z" };\nString[] NULL = { null };\nString[] NUMBER = { "0" };\nSystem.out.println(Arrays.compare(a, A)); // 32\nSystem.out.println(Arrays.compare(a, b)); // -1\nSystem.out.println(Arrays.compare(a, B)); // 31\nSystem.out.println(Arrays.compare(z, c_s)); // 23\nSystem.out.println(Arrays.compare(a, NULL)); // 1\nSystem.out.println(Arrays.compare(a, NUMBER)); // 49\n'))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"mismatch"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"the same => -1"),(0,i.kt)("li",{parentName:"ul"},"not the same => the first index they differ")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"int[] a1 = { 1, 3, 5, 7, 9 };\nint[] a2 = { 1, 3, 5, 7, 9 };\nint[] b1 = { 0, 2, 4, 6, 8 };\nint[] b2 = { 2, 4, 6, 8, 10 };\nint[] c1 = { 1, 3, 5, 7, 9, 11};\nint[] c2 = { 1, 3, 5, 7};\nSystem.out.println(Arrays.mismatch(a1, a2)); // -1\nSystem.out.println(Arrays.mismatch(a1, b1)); // 0\nSystem.out.println(Arrays.mismatch(a1, b2)); // 0\nSystem.out.println(Arrays.mismatch(a1, c1)); // 5\nSystem.out.println(Arrays.mismatch(a1, c2)); // 4\n"))),(0,i.kt)("li",{parentName:"ol"},"Multi-dimensional array",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'// 2D array\nint[][] a = {{ 1, 3, 5, 7, 9 }, { 2, 4, 6, 8, 10 }};\nint[] b[] = new int[5][5];\n// 3D array\nint[] c[][];\n// Asymmetric array\nint[] []d = new int[2][];\nd[0] = new int[3];\nd[1] = new int[6];\n// for loop\nfor(int i=0; i<a.length; i++){\n    for(int j=0; j<a[i].length; j++){\n        System.out.print(a[i][j]); // 13579246810\n    }\n}\nSystem.out.println("");\n// for each loop\nfor(int[] outer: a){\n    for(int inner: outer){\n        System.out.print(inner); // 13579246810\n    }\n}\n')))),(0,i.kt)("h3",{id:"math-api"},"Math API"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("a",{parentName:"li",href:"https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Math.html"},"https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Math.html")),(0,i.kt)("li",{parentName:"ol"},"Perform basic numeric operations such as the elementary ",(0,i.kt)("strong",{parentName:"li"},"exponential"),", ",(0,i.kt)("strong",{parentName:"li"},"logarithm"),", ",(0,i.kt)("strong",{parentName:"li"},"square root"),", and ",(0,i.kt)("strong",{parentName:"li"},"trigonometric")," functions."),(0,i.kt)("li",{parentName:"ol"},"Fields and some methods",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"static final double E // Base of natural logarithms\nstatic final double PI // ratio of circumference of a circle to its diameter\npublic static double min(double a, double b)\npublic static float min(float a, float b)\npublic static int min(int a, int b)\npublic static long min(long a, long b)\npublic static long round(double num)\npublic static int round(float num)\npublic static double ceil(double num)\npublic static double floor(double num)\npublic static double pow(double number, double exponent)\npublic static double random()\n")))),(0,i.kt)("h3",{id:"date-and-time"},"Date and Time"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"3 things: ",(0,i.kt)("strong",{parentName:"li"},"Date"),", ",(0,i.kt)("strong",{parentName:"li"},"Time")," and ",(0,i.kt)("strong",{parentName:"li"},"Timezone"),".",(0,i.kt)("ol",{parentName:"li"},(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"LocalDate")," contains Date only."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"LocalTime")," contains Time only."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"LocalDateTime")," contains Date and Time only."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"ZonedDateTime")," contains Date, Time and Timezone.")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"System.out.println(LocalDate.now()); // 2023-10-07\nSystem.out.println(LocalTime.now()); // 14:34:07.333623\nSystem.out.println(LocalDateTime.now()); // 2023-10-07T14:34:07.333692\nSystem.out.println(ZonedDateTime.now()); // 2023-10-07T14:34:07.333956+08:00[Asia/Hong_Kong]\n"))),(0,i.kt)("li",{parentName:"ol"},"Timezone offset can be listed as +08:00, GMT+8 or UTC+8."),(0,i.kt)("li",{parentName:"ol"},"Common Methods",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"public static LocalDate of(int year, int month, int dayOfMonth)\npublic static LocalDate of(int year, Month month, int dayOfMonth)\npublic static LocalTime of(int hour, int minute)\npublic static LocalTime of(int hour, int minute, int second)\npublic static LocalTime of(int hour, int minute, int second, int nanos)\npublic static LocalDateTime of(int year, int month, int dayOfMonth, int hour, int minute)\npublic static LocalDateTime of(int year, int month, int dayOfMonth, int hour, int minute, int second)\npublic static LocalDateTime of(int year, int month, int dayOfMonth, int hour, int minute, int second, int nanos)\npublic static LocalDateTime of(int year, int month, int dayOfMonth, int hour, int minute)\npublic static LocalDateTime of(int year, int month, int dayOfMonth, int hour, int minute, int second)\npublic static LocalDateTime of(int year, int month, int dayOfMonth, int hour, int minute, int second, int nanos)\n"))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"plus")," and ",(0,i.kt)("strong",{parentName:"li"},"minus")," method",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"plusYears()\nminusYears()\nplusMonths()\nminusMonths()\nplusWeeks()\nminusWeeks()\nplusDays()\nminusDays()\nplusHours()\nminusHours()\nplusMinutes()\nminusMinutes()\nplusSeconds()\nminusSeconds()\nplusNanos()\nminusNanos()\n"))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Period")," class",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"var date = ZonedDateTime.now();\nSystem.out.println(date); // 2023-10-07T14:48:31.417133+08:00[Asia/Hong_Kong]\nvar period = Period.ofMonths(2);\ndate.plus(period);\nSystem.out.println(date); // 2023-12-07T14:48:31.417133+08:00[Asia/Hong_Kong]\n"))),(0,i.kt)("li",{parentName:"ol"},"Period supports ",(0,i.kt)("em",{parentName:"li"},"years"),", ",(0,i.kt)("em",{parentName:"li"},"months"),", ",(0,i.kt)("em",{parentName:"li"},"weeks")," and ",(0,i.kt)("em",{parentName:"li"},"days"),"."),(0,i.kt)("li",{parentName:"ol"},"Period.of takes only year, months and days, ",(0,i.kt)("strong",{parentName:"li"},"without")," weeks."),(0,i.kt)("li",{parentName:"ol"},"Be aware of using invalid period on objects. For example, time has no years, months or days.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"var period = Period.of(1, 2, 3); // 1 year 2 months 3 days\nvar zonedDateTime = ZonedDateTime.now();\nvar localTime = LocalTime.now();\n# highlight-next-line\nzonedDateTime = zonedDateTime.plus(period);\n// This will error\nlocalTime = localTime.plus(period); // java.time.temporal.UnsupportedTemporalTypeException: Unsupported unit: Months\n"))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Duration")," class is for smaller units of time."),(0,i.kt)("li",{parentName:"ol"},"Duration supports ",(0,i.kt)("em",{parentName:"li"},"days"),", ",(0,i.kt)("em",{parentName:"li"},"hours"),", ",(0,i.kt)("em",{parentName:"li"},"minutes"),", ",(0,i.kt)("em",{parentName:"li"},"seconds"),", ",(0,i.kt)("em",{parentName:"li"},"milliseconds")," and ",(0,i.kt)("em",{parentName:"li"},"nanoseconds"),"."),(0,i.kt)("li",{parentName:"ol"},"Duration doesn't have a factory method that takes multiple units like Period.of."),(0,i.kt)("li",{parentName:"ol"},"Duration has a generic factory method that takes ",(0,i.kt)("strong",{parentName:"li"},"ChronoUnit"),".",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"var dateTime = LocalDateTime.now();\nSystem.out.println(dateTime); // 2023-10-07T15:11:07.554493\nvar halfDay = Duration.of(4, ChronoUnit.HALF_DAYS);\ndateTime = dateTime.plus(halfDay);\nSystem.out.println(dateTime); // 2023-10-09T15:11:07.554493\n"))),(0,i.kt)("li",{parentName:"ol"},"LocalDate, LocalTime, LocalDateTime, ZoneDateTime are ",(0,i.kt)("strong",{parentName:"li"},"temporal"),"."),(0,i.kt)("li",{parentName:"ol"},"ChronoUnit can tell the time gap between 2 temporals.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"var date1 = LocalDateTime.of( 2023, 10, 7, 0, 0);\nvar date2 = LocalDateTime.of( 2023, 10, 17, 0, 0);\n# highlight-next-line\nSystem.out.println(ChronoUnit.DAYS.between(date1, date2)); // 10\n"))),(0,i.kt)("li",{parentName:"ol"},"ChronoUnit is in the java.time.Temporal package."),(0,i.kt)("li",{parentName:"ol"},"Duration can only be used with object with time."),(0,i.kt)("li",{parentName:"ol"},"Period can only be used with object with date."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Instant")," specifies moment in ",(0,i.kt)("strong",{parentName:"li"},"GMT time zone"),".",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"System.out.println(ZonedDateTime.now()); // 2023-10-07T15:25:59.475706+08:00[Asia/Hong_Kong]\nSystem.out.println(ZonedDateTime.now().toInstant()); // 2023-10-07T07:25:59.475894Z\nSystem.out.println(Instant.now()); // 2023-10-07T07:25:59.477320Z\n"))),(0,i.kt)("li",{parentName:"ol"},"Daylight Saving Time. ",(0,i.kt)("ol",{parentName:"li"},(0,i.kt)("li",{parentName:"ol"},"March forwards from 1:59 am to 3:00 am. (Skip the hour, so 2:30 am doesn't exist)"),(0,i.kt)("li",{parentName:"ol"},"November falls back and experience hour 1:00 am to 1:59 am twice. (Repeat the hour)")))),(0,i.kt)("h2",{id:"methods"},"Methods"),(0,i.kt)("h3",{id:"introduction"},"Introduction"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"A method consists of the following. ",(0,i.kt)("strong",{parentName:"li"},"Bolded")," elements are mandatory.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Access modifier"),(0,i.kt)("li",{parentName:"ul"},"Optional specifier"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Return type")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Method name")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Parameter list")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Method Signature")," (Method name + Parameter list)"),(0,i.kt)("li",{parentName:"ul"},"Exception List"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Method body")," (Except for abstract method)"))),(0,i.kt)("li",{parentName:"ol"},"Access modifier and optional specifier can appear in any order.    "),(0,i.kt)("li",{parentName:"ol"},"Access modifier and optional specifier must all appear before return type.")),(0,i.kt)("h4",{id:"access-modifier"},"Access Modifier"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"private")," - same class",(0,i.kt)("admonition",{parentName:"li",type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"The access is on the class itself.\nEven if 2 classes are defined in the same java file, they cannot access private fields or methods of each other."))),(0,i.kt)("li",{parentName:"ol"},"package - same package, default access, no keyword"),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"protected")," - same package or subclass.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"There are 2 ways to access protected members.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"via inheritance, easy to understand"),(0,i.kt)("li",{parentName:"ul"},"via variable, i.e. reference type of the variable, ",(0,i.kt)("strong",{parentName:"li"},"check the relationship between the current class and the variable, whether they are of the same package or the current class is a subclass of the variable reference type"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'class Child extends Parent{\n    public Child(){\n        # highlight-next-line\n        System.out.println(whatIsProtected); // via inheritance\n    }\n}\nclass Peer{\n    void createParent(){\n        Parent parent = new Parent();\n        # highlight-next-line\n        System.out.println(parent.whatIsProtected); // via variable\n    }\n}\npublic class Parent {\n    protected String whatIsProtected= "Only for same package and subclass Here";\n    public static void main(String... args) {\n        Child child = new Child(); // Only for same package and subclass Here\n        Peer peer = new Peer();\n        peer.createParent(); // Only for same package and subclass Here\n    }\n}\n'))))),(0,i.kt)("li",{parentName:"ul"},"Please refer to book examples."))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"public")," - Anyone")),(0,i.kt)("h4",{id:"optional-specifier"},"Optional Specifier"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"static"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"abstract"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"final"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"default"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"synchronized"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"native"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"strictfp")),(0,i.kt)("li",{parentName:"ol"},"Some specifiers are not compatible with one another."),(0,i.kt)("li",{parentName:"ol"},"You can't declare a method ",(0,i.kt)("inlineCode",{parentName:"li"},"final")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"abstract"),".")),(0,i.kt)("h4",{id:"return-type"},"Return Type"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Appear after access modifier or optional specifier."),(0,i.kt)("li",{parentName:"ol"},"Appear before method name."),(0,i.kt)("li",{parentName:"ol"},"If there is no return type, use the keyword ",(0,i.kt)("inlineCode",{parentName:"li"},"void"),"."),(0,i.kt)("li",{parentName:"ol"},"Methods with a return type other than void must have a return statement inside the method body."),(0,i.kt)("li",{parentName:"ol"},"Methods with return type ",(0,i.kt)("inlineCode",{parentName:"li"},"void")," can either skip the return statement, or include return statement with no value returned.")),(0,i.kt)("h4",{id:"method-name"},"Method Name"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Review the section ",(0,i.kt)("a",{parentName:"li",href:"#declaring-variables"},"Building Blocks > Declaring variables")," for restrictions and convention for an identifier.")),(0,i.kt)("h4",{id:"parameter-list"},"Parameter List"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Required but doesn't have to contain any parameters."),(0,i.kt)("li",{parentName:"ol"},"Separate multiple parameters with comma.")),(0,i.kt)("h4",{id:"method-signature"},"Method Signature"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Composed of method name and parameter list."),(0,i.kt)("li",{parentName:"ol"},"Names of the parameters are not used as a part of a method signature."),(0,i.kt)("li",{parentName:"ol"},"Method signature only cares about the ",(0,i.kt)("strong",{parentName:"li"},"type")," and ",(0,i.kt)("strong",{parentName:"li"},"order")," of parameters in a parameter list."),(0,i.kt)("li",{parentName:"ol"},"Java uses it to uniquely identify which method you are trying to call.")),(0,i.kt)("h4",{id:"exception-list"},"Exception List"),(0,i.kt)("h4",{id:"method-body"},"Method Body"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"a code block with return statement."),(0,i.kt)("li",{parentName:"ol"},"requires to have a body unless declared ",(0,i.kt)("inlineCode",{parentName:"li"},"abstract"),".")),(0,i.kt)("h3",{id:"local-variables-and-instance-variables"},"Local variables and Instance variables"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Local variables")," are defined in a method or code block."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Instance variables")," are defined as a member of a class."),(0,i.kt)("li",{parentName:"ol"},"Only ",(0,i.kt)("inlineCode",{parentName:"li"},"final")," modifier can apply to local variables."),(0,i.kt)("li",{parentName:"ol"},"For final primitives, once it is assigned, its value cannot be modified."),(0,i.kt)("li",{parentName:"ol"},"For final object, once it is assigned, its ",(0,i.kt)("em",{parentName:"li"},"reference")," cannot be modified. Its content can however be modified."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Effectively final")," means the variable is not modified after assignment, even if it is not marked as final."),(0,i.kt)("li",{parentName:"ol"},"Local classes and lambda expressions declared within a method can only reference local variables that are final or effectively final."),(0,i.kt)("li",{parentName:"ol"},"Access modifier can be applied to ",(0,i.kt)("strong",{parentName:"li"},"instance variables"),"."),(0,i.kt)("li",{parentName:"ol"},"Optional specifier ",(0,i.kt)("inlineCode",{parentName:"li"},"final"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"transient"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"volatile")," can be applied to instance variables."),(0,i.kt)("li",{parentName:"ol"},"Compiler does not apply default value to final instance or final class variables."),(0,i.kt)("li",{parentName:"ol"},"If instance variables are marked final, they must be assigned a value when it is declared or when the object is instantiated.")),(0,i.kt)("h3",{id:"methods-with-varargs"},"Methods with Varargs"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"A method may use a ",(0,i.kt)("strong",{parentName:"li"},"varargs")," parameter with below rules:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"It can have ",(0,i.kt)("strong",{parentName:"li"},"at most 1")," varargs parameter."),(0,i.kt)("li",{parentName:"ul"},"Varargs parameter must be the ",(0,i.kt)("strong",{parentName:"li"},"last parameter"),".")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"static void method(String... p1) {};\nstatic void method(String p1, String... p2) {};\n// This will error\nstatic void method(String... p1, String p2) {}; // violation: Last parameter\n// This will error\nstatic void method(String... p1, String... p2) {}; // violation: At most 1 varargs parameter\n"))),(0,i.kt)("li",{parentName:"ol"},"When calling method, you can either:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"pass in an array"),(0,i.kt)("li",{parentName:"ul"},"or list the elements and let Java create for you")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'static void print(String... names) {\n    for(String name : names) System.out.println(name);\n}\npublic static void main(String... args) {\n    # highlight-next-line\n    print( new String[]{"Mary", "Cindy", "Amy"} ); // pass in array\n    # highlight-next-line\n    print("June", "Jane", "Becky"); // list the elements\n}\n'))),(0,i.kt)("li",{parentName:"ol"},"The method will receive the array containing the elements."),(0,i.kt)("li",{parentName:"ol"},"Java will create an array of length 0 if varargs is omitted.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"static void print(String... names) {\n   System.out.println(names.length);\n}\npublic static void main(String... args) {\n    # highlight-next-line\n    print(); // 0\n}\n"))),(0,i.kt)("li",{parentName:"ol"},"Accessing a varargs parameter is like accessing array. It has the same array indexing."),(0,i.kt)("li",{parentName:"ol"},"If passing null to varargs parameter, java will treat it as array reference and result in NullPointerException.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'static void print(String... names) {\n    System.out.println(names.length);\n}\npublic static void main(String... args) {\n    // This will error\n    print(null); // java.lang.NullPointerException: Cannot read the array length because "a" is null\n}\n')))),(0,i.kt)("h3",{id:"static"},"Static"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"static")," can be applied to ",(0,i.kt)("em",{parentName:"li"},"class"),", ",(0,i.kt)("em",{parentName:"li"},"method")," and ",(0,i.kt)("em",{parentName:"li"},"variable"),"."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"static")," can be applied to ",(0,i.kt)("em",{parentName:"li"},"import statement"),"."),(0,i.kt)("li",{parentName:"ol"},"The target will then belong to the class rather than a specific instance of the class."),(0,i.kt)("li",{parentName:"ol"},"Static methods have 2 main purpose.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Utility / Helper methods that don't require any ",(0,i.kt)("strong",{parentName:"li"},"object state"),"."),(0,i.kt)("li",{parentName:"ul"},"For state that is shared by all instances."))),(0,i.kt)("li",{parentName:"ol"},"You can use an instance of the class to call the static method. The compiler ",(0,i.kt)("strong",{parentName:"li"},"checks for the type of the reference and uses that instead of the object"),".",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'public class Test {\n    public static String everyone = "Everyone";\n    public static void main(String... args) {\n        Test test = null;\n        System.out.println(Test.everyone); // Everyone\n        System.out.println(test.everyone); // Everyone\n    }\n}\n')),"Java doesn't care the variable ",(0,i.kt)("em",{parentName:"li"},"test")," is null as it is looking for a static variable."),(0,i.kt)("li",{parentName:"ol"},"Static member doesn't require an instance to use."),(0,i.kt)("li",{parentName:"ol"},"Instance member require an instance to use."),(0,i.kt)("li",{parentName:"ol"},"A static method can call another static method."),(0,i.kt)("li",{parentName:"ol"},"A static method ",(0,i.kt)("strong",{parentName:"li"},"cannot")," call instance method without referencing instance of class, even it is within the ssame class."),(0,i.kt)("li",{parentName:"ol"},"An instance method can call static method."),(0,i.kt)("li",{parentName:"ol"},"An instance method can call another instance method within the same class."),(0,i.kt)("li",{parentName:"ol"},"Static variable can be declared with same modifiers as instance variables such as ",(0,i.kt)("inlineCode",{parentName:"li"},"final"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"transient")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"volatile"),"."),(0,i.kt)("li",{parentName:"ol"},"When a static variable is declared final, the compiler will not assigned it with default value. It must be initialized with a value."),(0,i.kt)("li",{parentName:"ol"},"Use ",(0,i.kt)("strong",{parentName:"li"},"static initializer")," to initialize static final variables.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"static int a;\nfinal static int b;\n// This will error\nfinal static int c; // Compile error as c is final and not initialized\nstatic{ // static initializer\n    b = 5;\n}\n"))),(0,i.kt)("li",{parentName:"ol"},"Instance Initializer / Constructor cannot initialize static final variables."),(0,i.kt)("li",{parentName:"ol"},"All static initializers run when the class is ",(0,i.kt)("em",{parentName:"li"},"first used"),", in the order they are defined.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'static {\n    System.out.println("cp 1");\n}\nstatic {\n    System.out.println("cp 2");\n}\n')),"cp1 will print before cp2."),(0,i.kt)("li",{parentName:"ol"},"Try to avoid instance initializer. Use constructor instead."),(0,i.kt)("li",{parentName:"ol"},"Use static initializer if initializing static variables uses more than one line. Put all static initialization in the same block."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Static import")," can import static member of classes.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"import java.time.Duration;\n# highlight-next-line\nimport static java.time.Duration.ofDays;\npublic class Test {\n    public static void main(String... args) {\n        # highlight-next-line\n        Duration duration = ofDays(1); // ofDays instead of Duration.ofDays\n        System.out.println(duration); // PT24H\n    }\n}\n"))),(0,i.kt)("li",{parentName:"ol"},"Static import allows you not to specify where each static method or variable comes from each time you use it."),(0,i.kt)("li",{parentName:"ol"},"Static import can only import static members."),(0,i.kt)("li",{parentName:"ol"},"Static import cannot import class. To import class, use regular import instead."),(0,i.kt)("li",{parentName:"ol"},"You cannot static import 2 or more static members with the same name. In that case, refer to static member via their class name.")),(0,i.kt)("h3",{id:"pass-by-value"},"Pass by value"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Java is a pass-by-value language."),(0,i.kt)("li",{parentName:"ol"},"When a method is invoked, it receives ",(0,i.kt)("strong",{parentName:"li"},"copy")," of the parameter from the caller."),(0,i.kt)("li",{parentName:"ol"},"Assignments made to the parameter in the method do not affect the caller."),(0,i.kt)("li",{parentName:"ol"},"When passing a primitive, the method receives a copy of primitive's value.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'static void increment(int i){\n    i += 1;\n    System.out.println( "Callee: " + i ); // Callee: 1001\n}\npublic static void main(String... args) {\n    int salary = 1000;\n    increment(salary);\n    System.out.println( "Caller: " + salary ); // Caller: 1000\n}\n'))),(0,i.kt)("li",{parentName:"ol"},"When passing an object, the method receives a copy of reference.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'static void reassign(StringBuilder sb){\n    sb = new StringBuilder("Happy Valley");\n    System.out.println( "Callee: " + sb ); // Callee: Happy Valley\n}\npublic static void main(String... args) {\n   var sb = new StringBuilder("Hello World");\n   reassign(sb);\n   System.out.println( "Caller: " + sb ); // Caller: Hello World\n}\n')),"Note sb in the main method is still pointing to the Stringbuilder with value Hello World."),(0,i.kt)("li",{parentName:"ol"},"Note the above example focus on assignment of variables, and show that any assignments made to the parameter in the method do not affect the caller."),(0,i.kt)("li",{parentName:"ol"},"When passing an object to a method, the method receives a copy of reference, but that copy of reference ",(0,i.kt)("strong",{parentName:"li"},"points to the same object")," as the caller."),(0,i.kt)("li",{parentName:"ol"},"Changes made to the object will be available to both references (caller and callee).",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'static void append(StringBuilder sb){\n    sb.append(" and Happy new year.");\n    System.out.println( "Callee: " + sb); // Callee: Hello World and Happy new year.\n}\npublic static void main(String... args) {\n   var sb = new StringBuilder("Hello World");\n   append(sb);\n   System.out.println( "Caller: " + sb); // Caller: Hello World and Happy new year\n}\n')))),(0,i.kt)("h3",{id:"returning-data"},"Returning data"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Method can return data. However be careful if the caller ignores the data returned.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'static String change(String str){\n    str += " Wong";\n    return str;\n}\npublic static void main(String... args) {\n   var a1 = "Mary";\n   var a2 = "Amy";\n   a1= change(a1);\n   # highlight-next-line\n   change(a2); // ignores the data returned\n   System.out.println(a1); // Mary Wong\n   System.out.println(a2); // Amy\n}\n')))),(0,i.kt)("h3",{id:"autoboxing-and-unboxing"},"Autoboxing and Unboxing"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Java will automatically convert between primitives and wrapper classes."),(0,i.kt)("li",{parentName:"ol"},"Autoboxing: primitive -> wrapper class"),(0,i.kt)("li",{parentName:"ol"},"Unboxing: wrapper class -> primitive"),(0,i.kt)("li",{parentName:"ol"},"Java will implicitly cast a smaller primitive to larger one, and autobox a primitive to wrapper, but it will ",(0,i.kt)("strong",{parentName:"li"},"NOT")," do both.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"float f = 1.0f;\ndouble d1 = f;\nDouble d2 = d1;\n// This will error\nDouble d3 = f; // Compilation error - java: incompatible types: float cannot be converted to java.lang.Double\n"))),(0,i.kt)("li",{parentName:"ol"},"Unboxing a null value will throw NullPointerException.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'Double a = null;\n// This will error\ndouble b = a; // java.lang.NullPointerException: Cannot invoke "java.lang.Double.doubleValue()" because "a" is null\n')))),(0,i.kt)("h3",{id:"overloading"},"Overloading"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Overloading methods have the same method name but different parameters lists. "),(0,i.kt)("li",{parentName:"ol"},"Overloading methods must have different method signature. "),(0,i.kt)("li",{parentName:"ol"},"You cannot declare duplicate methods (same method signature) in the same class."),(0,i.kt)("li",{parentName:"ol"},"Things other than method name can vary for overloading methods, such as access modifier, optional specifier, return type, exception list, etc."),(0,i.kt)("li",{parentName:"ol"},"Java picks ",(0,i.kt)("strong",{parentName:"li"},"the most specific version")," it can when calling overloading methods, be it primitive or reference type."),(0,i.kt)("li",{parentName:"ol"},"The same applies to autoboxing when both primitive and wrapper version are present as overloading methods. Java picks the most specific version.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'static void print(int a) { System.out.println("Primitive method is called.");}\nstatic void print(Integer a) { System.out.println("Wrapper method is called.");}\npublic static void main(String... args) {\n    int primitive = 1 ;\n    Integer wrapper = 2;\n    print(primitive); // Primitive method is called.\n    print(wrapper); // Wrapper method is called.\n}\n'))),(0,i.kt)("li",{parentName:"ol"},"Array does not autobox.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"static void method(Integer[] i){};\npublic static void main (String... args){\n    int[] i = { 1, 2, 3 };\n    // This will error\n    method(i); // Compile error: java: incompatible types: int[] cannot be converted to java.lang.Integer[]\n} \n"))),(0,i.kt)("li",{parentName:"ol"},"Java treats varargs as if they were an array. Method signature will be the same as an array, and lead to duplicate method error.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"static void method(Integer[] i){};\n// This will error\nstatic void method(Integer... i){}; // java: cannot declare both method(java.lang.Integer...) and method(java.lang.Integer[])\n"))),(0,i.kt)("li",{parentName:"ol"},"Overloading order is listed below in order of precedence.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Exact match by type"),(0,i.kt)("li",{parentName:"ul"},"Larger primitive type"),(0,i.kt)("li",{parentName:"ul"},"Autoboxed type"),(0,i.kt)("li",{parentName:"ul"},"varargs")))),(0,i.kt)("h2",{id:"class-design"},"Class Design"),(0,i.kt)("h3",{id:"inheritance"},"Inheritance"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"A ",(0,i.kt)("strong",{parentName:"li"},"subclass")," automatically includes certain members of its parent class."),(0,i.kt)("li",{parentName:"ol"},"Use the keyword ",(0,i.kt)("inlineCode",{parentName:"li"},"extends")," to declare subclass.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"class Parent{}\nclass Child extends Parent{}\n"))),(0,i.kt)("li",{parentName:"ol"},"Inheritance is ",(0,i.kt)("strong",{parentName:"li"},"transitive"),". If A extends B, and B extends C, then A is also a subclass of C."),(0,i.kt)("li",{parentName:"ol"},"All public and protected members are automatically available to child class."),(0,i.kt)("li",{parentName:"ol"},"Package members (same package as the child) are available to child class."),(0,i.kt)("li",{parentName:"ol"},"Private members are ",(0,i.kt)("strong",{parentName:"li"},"NEVER")," available via inheritance."),(0,i.kt)("li",{parentName:"ol"},"You cannot ",(0,i.kt)("inlineCode",{parentName:"li"},"extends")," a ",(0,i.kt)("strong",{parentName:"li"},"final")," class."),(0,i.kt)("li",{parentName:"ol"},"Java supports ",(0,i.kt)("strong",{parentName:"li"},"single inheritance")," but not multiple inheritance. A class can inherit from only one parent class.")),(0,i.kt)("h3",{id:"javalangobject"},"java.lang.Object"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"All class inherit from ",(0,i.kt)("strong",{parentName:"li"},"java.lang.Object"),"."),(0,i.kt)("li",{parentName:"ol"},"If a class doesn't extend another class, the compiler will automatically add the syntax ",(0,i.kt)("em",{parentName:"li"},"extends java.lang.Object"),"."),(0,i.kt)("li",{parentName:"ol"},"Primitive type doesn't inherit from java.lang.Object."),(0,i.kt)("li",{parentName:"ol"},"Wrapper class inherits from java.lang.Object.")),(0,i.kt)("h3",{id:"access-modifier-1"},"Access modifier"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"A top level class is one not defined in another class, i.e. not nested class."),(0,i.kt)("li",{parentName:"ol"},"You don't have to declare a top level class ",(0,i.kt)("inlineCode",{parentName:"li"},"public"),".",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"#highlight-next-line\nclass Test {}\n"))),(0,i.kt)("li",{parentName:"ol"},"You cannot declare a top level class ",(0,i.kt)("inlineCode",{parentName:"li"},"private")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"protected"),".",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"// This will error\nprivate class Test {}\n"))),(0,i.kt)("li",{parentName:"ol"},"You can declare a nested class with any access modifier.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"class Test {\n    {/* highlight-start */}\n    public class Nested1{}\n    class Nested2{}\n    protected class Nested3{}\n    private class Nested4{}\n    {/* highlight-end */}\n}\n")))),(0,i.kt)("h3",{id:"this"},(0,i.kt)("inlineCode",{parentName:"h3"},"this")),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Local variable and Instance variable can have the same name."),(0,i.kt)("li",{parentName:"ol"},"By default, Java will use the most granular scope, i.e. it will use the local variable."),(0,i.kt)("li",{parentName:"ol"},"To use the instance variable instead of the local variable, use the keyword ",(0,i.kt)("inlineCode",{parentName:"li"},"this"),".",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'public class Test {\n    String name = "Peter";\n    public void print(String name){\n        System.out.println(name);\n        #highlight-next-line\n        System.out.println(this.name);\n    }\n    public static void main(String... args) {\n        Test test = new Test();\n        test.print("John");\n    }\n}\n')),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-txt",metastring:"title='Result'",title:"'Result'"},"John\nPeter\n"))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"this")," cannot be used in static method or static initializer.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'public class Test {\n    String name = "Peter";\n    public static void print(String name){\n        // This will error\n        System.out.println(this.name); // Compilation error - java: non-static variable this cannot be referenced from a static context\n    }\n    static{\n        // This will error\n        System.out.println(this.name); // Compilation error - java: non-static variable this cannot be referenced from a static context\n    }\n}\n'))),(0,i.kt)("li",{parentName:"ol"},"The use of ",(0,i.kt)("inlineCode",{parentName:"li"},"this")," is optional. When Java encounters a variable, it will check the class hierarchy.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'public class Test {\n    String name = "Peter";\n    public void print(){\n        #highlight-next-line\n        System.out.println(name); // Print Peter\n        #highlight-next-line\n        System.out.println(this.name); // Print Peter\n    }\n    public static void main(String... args){\n        Test test = new Test();\n        test.print(); \n    }\n}\n')),"Unless a local variable with the same name exists, it is not necessary to use ",(0,i.kt)("inlineCode",{parentName:"li"},"this")," to refer an instance variable.")),(0,i.kt)("h3",{id:"super"},(0,i.kt)("inlineCode",{parentName:"h3"},"super")),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"You can refer a parent variable or method with ",(0,i.kt)("inlineCode",{parentName:"li"},"super"),".",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'class Parent{\n    String name = "John";\n}\npublic class Test extends Parent{\n    String name = "Peter";\n    public void print(){\n        System.out.println(this.name); // Print Peter\n        #highlight-next-line\n        System.out.println(super.name); // Print John\n    }\n    public static void main(String... args){\n        Test test = new Test();\n        test.print();\n    }\n}\n'))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"super")," excludes any members found in the current class.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'class Parent{}\nclass Child extends Parent{\n    String name = "Peter";\n    public void print(){\n        // This will error\n        System.out.println(super.name); // Compilation error - java: cannot find symbol, symbol: variable name\n    }\n    public static void main(String... args){\n        Child child = new Child();\n        child.print();\n    }\n}\n'))),(0,i.kt)("li",{parentName:"ol"},"Since ",(0,i.kt)("inlineCode",{parentName:"li"},"this")," includes inherited members, you only use ",(0,i.kt)("inlineCode",{parentName:"li"},"super")," when you have a naming conflict via inheritance, and that you need to use the member of parent specifically.")),(0,i.kt)("h3",{id:"constructor"},"Constructor"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"A constructor has the same name as the class."),(0,i.kt)("li",{parentName:"ol"},"A constructor has no return type."),(0,i.kt)("li",{parentName:"ol"},"Parameter type cannot be var."),(0,i.kt)("li",{parentName:"ol"},"A class can have multiple constructors with different signature. This is called ",(0,i.kt)("strong",{parentName:"li"},"constructor overloading"),"."),(0,i.kt)("li",{parentName:"ol"},"Constructor is used when creating a new object. This is called ",(0,i.kt)("strong",{parentName:"li"},"instantiation"),"."),(0,i.kt)("li",{parentName:"ol"},"If you don't include any constructors in the class, Java will create a ",(0,i.kt)("strong",{parentName:"li"},"no-argument default constructor"),"."),(0,i.kt)("li",{parentName:"ol"},"Compiler only inserts the default constructor when no constructor is defined.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"public class Test\n{\n    public Test(String name){}\n    public static void main(String... args){\n        // This will error\n        Test test = new Test(); // Compilation error\n    }\n}\n")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-txt",metastring:"title='Result'",title:"'Result'"},"java: constructor Test in class Test cannot be applied to given types;\n    required: java.lang.String\n    found:    no arguments\n    reason: actual and formal argument lists differ in length\n"))),(0,i.kt)("li",{parentName:"ol"},"A private constructor cannot be called by other classes."),(0,i.kt)("li",{parentName:"ol"},"If a class only has private constructors, there is no way for other classes to instantiate it. Design pattern like Singleton uses this technique to control and prevent other classes from instantiating a class via ",(0,i.kt)("inlineCode",{parentName:"li"},"new"),"."),(0,i.kt)("li",{parentName:"ol"},"A constructor can call one another using this().",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'public class Test\n{\n    public Test(){\n        #highlight-next-line\n        this("Hello World");\n        System.out.println("Constructor with no parameter is called.");\n    }\n    public Test(String message){\n        System.out.println("Constructor with String parameter ( %s ) is called.".formatted(message));\n    }\n    public static void main(String... args){\n        Test test = new Test();\n    }\n}\n')),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-txt",metastring:"title='Result'",title:"'Result'"},"Constructor with String parameter ( Hello World ) is called.\nConstructor with no parameter is called.\n"))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"this()")," call must be first statement in constructor.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'public class Test\n{\n    public Test(){\n        System.out.println("Constructor with no parameter is called.");\n        // This will error\n        this("Hello World"); // Compilation error - java: call to this must be first statement in constructor\n    }\n    public Test(String message){\n        System.out.println("Constructor with String parameter ( %s ) is called.".formatted(message));\n    }\n    public static void main(String... args){\n        Test test = new Test();\n    }\n}\n'))),(0,i.kt)("li",{parentName:"ol"},"A constructor cannot use this() to call itself.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"public class Test\n{\n    public Test(){\n        // This will error\n        this(); // Compilation error - java: recursive constructor invocation\n    }\n    public static void main(String... args){\n        Test test = new Test();\n    }\n}\n"))),(0,i.kt)("li",{parentName:"ol"},"You can use ",(0,i.kt)("inlineCode",{parentName:"li"},"super()")," to call parent constructor.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'class Parent{\n    public Parent(){\n        System.out.println("I am Parent");\n    }\n    public Parent(String name){\n        System.out.println("I am %s".formatted(name));\n    }\n}\nclass Child extends Parent{\n    public Child(){\n        #highlight-next-line\n        super();\n        System.out.println("I am Child");\n    }\n    public Child(String childName, String parentName){\n        #highlight-next-line\n        super(parentName);\n        System.out.println("I am %s".formatted(childName));\n    }\n    public static void main(String... args){\n        Child child1 = new Child();\n        Child child2 = new Child("Alucard", "Dracula");\n    }\n}\n')),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-txt",metastring:"title='Result'",title:"'Result'"},"I am Parent\nI am Child\nI am Dracula\nI am Alucard\n"))),(0,i.kt)("li",{parentName:"ol"},"First line of every constructor is a call to either ",(0,i.kt)("inlineCode",{parentName:"li"},"super()")," or overloaded constructor using ",(0,i.kt)("inlineCode",{parentName:"li"},"this()"),"."),(0,i.kt)("li",{parentName:"ol"},"Like ",(0,i.kt)("inlineCode",{parentName:"li"},"this()"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"super()")," call must also be first statement in constructor.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'class Parent{\n    public Parent(){\n        System.out.println("I am Parent");\n    }\n}\nclass Child extends Parent{\n    public Child(){\n        System.out.println("I am Child");\n        // This will error\n        super(); // Compilation error - java: call to super must be first statement in constructor\n    }\n    public static void main(String... args){\n        Child child = new Child();\n    }\n}\n'))),(0,i.kt)("li",{parentName:"ol"},"Java compiler automatically inserts a call to the no-argument constructor ",(0,i.kt)("inlineCode",{parentName:"li"},"super()")," if you do not explicitly call ",(0,i.kt)("inlineCode",{parentName:"li"},"this()")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"super()")," as the first line of a constructor.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'class Parent{\n    public Parent(){\n        System.out.println("I am Parent");\n    }\n}\nclass Child extends Parent{\n    public Child(){\n        System.out.println("I am Child");\n    }\n    public static void main(String... args){\n        Child child = new Child();\n    }\n}    \n')),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-txt",metastring:"title='Result'",title:"'Result'"},"I am Parent\nI am Child\n"))),(0,i.kt)("li",{parentName:"ol"},"Java compiler only knows how to add no-argument default constructor. It does ",(0,i.kt)("strong",{parentName:"li"},"NOT")," detect and add default constructor that have arguments. You must understand how the compiler add default constructor and ",(0,i.kt)("inlineCode",{parentName:"li"},"super()"),"."),(0,i.kt)("li",{parentName:"ol"},"In case Java compiler cannot implicitly add default constructor due to absence of no-argument constructor in the parent class, you must explicitly call the correct parent constructor in the child constructor. ",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'class Parent{\n    public Parent( String name ){}\n}\n// This will error\nclass Child1 extends Parent{} // Compilation error - java: constructor Parent in class Parent cannot be applied to given types\n// This will error\nclass Child2 extends Parent{ // Compilation error - java: constructor Parent in class Parent cannot be applied to given types\n    // This will error\n    public Child2(){}\n// This will error    \n}\nclass Child extends Parent{\n    public Child(){\n        #highlight-next-line\n        super( "Bob" );\n    }\n} \n')),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-txt",metastring:"title='Compilation error'",title:"'Compilation","error'":!0},"java: constructor Parent in class Parent cannot be applied to given types;\nrequired: java.lang.String\nreason: actual and formal argument lists differ in length\n"))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"super()")," always refers to the most direct parent.")),(0,i.kt)("h3",{id:"initialization"},"Initialization"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Class is loaded by JVM before it can be used."),(0,i.kt)("li",{parentName:"ol"},"Each class is initialized ",(0,i.kt)("strong",{parentName:"li"},"at most once"),"."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Class initialization")," in the following order:",(0,i.kt)("ol",{parentName:"li"},(0,i.kt)("li",{parentName:"ol"},"Superclass is initialized before subclass."),(0,i.kt)("li",{parentName:"ol"},"static variable is processed in the order in which they appear in the class."),(0,i.kt)("li",{parentName:"ol"},"static initializer is processed in the order in which they appear in the class."))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"final")," instance fields will not be assigned with default values. They must be assigned ",(0,i.kt)("strong",{parentName:"li"},"exactly once")," by the time the constructor completes."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"final")," Instance fields can be assigned in 3 areas.",(0,i.kt)("ol",{parentName:"li"},(0,i.kt)("li",{parentName:"ol"},"The same line they are declared"),(0,i.kt)("li",{parentName:"ol"},"Initializer"),(0,i.kt)("li",{parentName:"ol"},"Constructor"))),(0,i.kt)("li",{parentName:"ol"},"Remember ",(0,i.kt)("strong",{parentName:"li"},"final")," fields can be assigned only once.    "),(0,i.kt)("li",{parentName:"ol"},"Unlike ",(0,i.kt)("inlineCode",{parentName:"li"},"final")," ",(0,i.kt)("strong",{parentName:"li"},"local")," variables, which are not required to have a value unless they are actually used, ",(0,i.kt)("inlineCode",{parentName:"li"},"final")," ",(0,i.kt)("strong",{parentName:"li"},"instance")," variables must be assigned a value.    "),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Instance initialization")," in the following order:",(0,i.kt)("ol",{parentName:"li"},(0,i.kt)("li",{parentName:"ol"},"Class initialization if target class is not initialized."),(0,i.kt)("li",{parentName:"ol"},"If target class has superclass, initialize the instance of its super class."),(0,i.kt)("li",{parentName:"ol"},"Instance variable in the order in which they appear in the class."),(0,i.kt)("li",{parentName:"ol"},"Instance initializer in the order in which they appear in the class."),(0,i.kt)("li",{parentName:"ol"},"Constructor")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'class Parent{\n    static{\n        System.out.println("Parent static initializer");\n    }\n    {\n        System.out.println("Parent instance initializer");\n    }\n    public Parent(){\n        System.out.println("Parent constructor");\n    }\n}\nclass Child extends Parent{\n    static{\n        System.out.println("Child static initializer");\n    }\n    {\n        System.out.println("Child instance initializer");\n    }\n    public Child(){\n        System.out.println("Child constructor");\n    }\n    public static void main(String... args){\n        Child child1 = new Child();\n        Child child2 = new Child();\n    }\n} \n')),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-txt",metastring:"title='Result'",title:"'Result'"},"Parent static initializer\nChild static initializer\nParent instance initializer\nParent constructor\nChild instance initializer\nChild constructor\nParent instance initializer\nParent constructor\nChild instance initializer\nChild constructor\n")))),(0,i.kt)("h3",{id:"overriding-and-hiding"},"Overriding and Hiding"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"You cannot override or hide ",(0,i.kt)("inlineCode",{parentName:"li"},"private")," methods since they are not inherited."),(0,i.kt)("li",{parentName:"ol"},"Rules for ",(0,i.kt)("strong",{parentName:"li"},"overriding")," an instance method:",(0,i.kt)("ol",{parentName:"li"},(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Same method signature")," as its parent method.   "),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"At least as accessible as")," its parent method. Can be more accessible. Cannot be more restrictive."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Must not throw new or broader exception")," than its parent method."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Return type must be the same or a subtype")," of its parent method."))),(0,i.kt)("li",{parentName:"ol"},"A static method cannot be overridden."),(0,i.kt)("li",{parentName:"ol"},"A static method can be hidden."),(0,i.kt)("li",{parentName:"ol"},"When both the parent and the child defines a static method with the same signature, the parent one will be hidden when accessing with child reference. This is called ",(0,i.kt)("strong",{parentName:"li"},"method hiding"),"."),(0,i.kt)("li",{parentName:"ol"},"Rules for ",(0,i.kt)("strong",{parentName:"li"},"hiding")," a static method:",(0,i.kt)("ol",{parentName:"li"},(0,i.kt)("li",{parentName:"ol"},"Rules for overriding an instance method apply."),(0,i.kt)("li",{parentName:"ol"},"If the method is defined as static in the parent, the child must also define it as static."))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Method hiding")," if both methods in the parent and child are static.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java",metastring:"title='Method hiding'",title:"'Method","hiding'":!0},'class Parent{\n   #highlight-next-line\n   static void welcome(){\n       System.out.println("Hello");\n   }\n}\nclass Child extends Parent{\n   #highlight-next-line\n   static void welcome(){\n       System.out.println("hi");\n   }\n   public static void main(String... args){\n       Child child = null;\n       child.welcome(); // print hi\n   }\n}\n'))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Method overriding")," if both methods in the parent and child are NOT static.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java",metastring:"title='Method overriding'",title:"'Method","overriding'":!0},'class Parent{\n    #highlight-next-line\n    void welcome(){\n        System.out.println("Hello");\n    }\n}\nclass Child extends Parent{\n    #highlight-next-line\n    void welcome(){\n        System.out.println("hi");\n    }\n    public static void main(String... args){\n        Child child = new Child();\n        child.welcome(); // print hi\n    }\n}\n'))),(0,i.kt)("li",{parentName:"ol"},"Compilation error occurs if one is static and the other one is not static.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'class Parent{\n    static void welcome(){\n        System.out.println("Hello");\n    }\n}\nclass Child extends Parent{\n    // This will error\n    void welcome(){ // Compilation error - java: welcome() in Child cannot override welcome() in Parent, overridden method is static\n        System.out.println("hi");\n    }\n    public static void main(String... args){\n        Child child = new Child();\n        child.welcome(); // print hi\n    }\n}\n'))),(0,i.kt)("li",{parentName:"ol"},"Variable cannot be overridden. It can only be hidden."),(0,i.kt)("li",{parentName:"ol"},"If both the parent and child defines an instance variable with the same name, there will be 2 copies of variables. The parent one will be hidden if the variable is accessed by child reference."),(0,i.kt)("li",{parentName:"ol"},"Overriding a method replaces the parent method on all reference variables (other than super).",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java",metastring:"title='Overriding an instance method'",title:"'Overriding",an:!0,instance:!0,"method'":!0},'class Parent{\n    #highlight-next-line\n    void welcome(){\n        System.out.println("Hello");\n    }\n}\nclass Child extends Parent{\n    #highlight-next-line\n    void welcome(){\n        System.out.println("hi");\n    }\n    public static void main(String... args){\n        Child child = new Child();\n        Parent parent = child;\n        #highlight-next-line\n        child.welcome(); // print hi\n        #highlight-next-line\n        parent.welcome(); // print hi\n    }\n}    \n'))),(0,i.kt)("li",{parentName:"ol"},"Hiding a method or variable replaces the member only if a child reference type is used.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java",metastring:"title='Hiding a static method'",title:"'Hiding",a:!0,static:!0,"method'":!0},'class Parent{\n    #highlight-next-line\n    static void welcome(){\n        System.out.println("Hello");\n    }\n}\nclass Child extends Parent{\n    #highlight-next-line\n    static void welcome(){\n        System.out.println("hi");\n    }\n    public static void main(String... args){\n        Child child = new Child();\n        Parent parent = child;\n        #highlight-next-line\n        child.welcome(); // print hi\n        #highlight-next-line\n        parent.welcome(); // print Hello\n    }\n}\n')),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java",metastring:"title='Hiding a variable'",title:"'Hiding",a:!0,"variable'":!0},'class Parent{\n    #highlight-next-line\n    String name = "Dracula";\n}\nclass Child extends Parent{\n    #highlight-next-line\n    String name = "Alucard";\n    public static void main(String... args){\n        Child child = new Child();\n        Parent parent = child;\n        #highlight-next-line\n        System.out.println(child.name); // Alucard\n        #highlight-next-line\n        System.out.println(parent.name); // Dracula\n    }\n}    \n'))),(0,i.kt)("li",{parentName:"ol"},"You cannot override / hide a final method.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'class Parent{\n    final void welcome(){\n        System.out.println("Hello");\n    }\n}\nclass Child extends Parent{\n    // This will error\n    void welcome(){ // Compilation error - welcome() in Child cannot override welcome() in Parent, overridden method is final\n        System.out.println("hi");\n    }\n}    \n')),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'class Parent{\n    static final void welcome(){\n        System.out.println("Hello");\n    }\n}\nclass Child extends Parent{\n    // This will error\n    static void welcome(){ // Compilation error - welcome() in Child cannot override welcome() in Parent, overridden method is static,final\n        System.out.println("hi");\n    }\n}    \n'))),(0,i.kt)("li",{parentName:"ol"},"The above rule only applies to inherited method. Private methods are redeclared, not overridden or hidden. So no compilation error occurs below.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'class Parent{\n    #highlight-next-line        \n    private final void welcome(){\n        System.out.println("Hello");\n    }\n}\nclass Child extends Parent{\n    #highlight-next-line\n    private void welcome(){\n        System.out.println("hi");\n    }\n}    \n')),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},'class Parent{\n    #highlight-next-line\n    private static final void welcome(){\n        System.out.println("Hello");\n    }\n}\nclass Child extends Parent{\n    #highlight-next-line\n    private static void welcome(){\n        System.out.println("hi");\n    }\n}  \n')))),(0,i.kt)("h3",{id:"abstract-class"},"Abstract Class"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"You can use keyword ",(0,i.kt)("inlineCode",{parentName:"li"},"abstract")," to define an abstract class."),(0,i.kt)("li",{parentName:"ol"},"An abstract class cannot be instantiated."),(0,i.kt)("li",{parentName:"ol"},"An abstract class can contain abstract instance method(s)."),(0,i.kt)("li",{parentName:"ol"},"An abstract class is not required to include any abstract methods."),(0,i.kt)("li",{parentName:"ol"},"An abstract method does not define a body."),(0,i.kt)("li",{parentName:"ol"},"By declaring a method abstract, we can guarantee that some version will be available on an instance without having to specify what that version is in the abstract parent class."),(0,i.kt)("li",{parentName:"ol"},"The overridden method will be used at runtime. This is runtime polymorphism, the object can take many form."),(0,i.kt)("li",{parentName:"ol"},"Only instance method can be abstract. Variables, static methods etc cannot be abstract."),(0,i.kt)("li",{parentName:"ol"},"Abstract instance method can only be declared in abstract class."),(0,i.kt)("li",{parentName:"ol"},"A concrete class is a non-abstract class."),(0,i.kt)("li",{parentName:"ol"},"Concrete class that inherits the abstract class must implement all inherited abstract methods."),(0,i.kt)("li",{parentName:"ol"},"Overriding an abstract method sticks to same rules of overriding methods."),(0,i.kt)("li",{parentName:"ol"},"An abstract class can have constructors."),(0,i.kt)("li",{parentName:"ol"},"Abstract classes are initialized with constructors in the same way as non-abstract classes."),(0,i.kt)("li",{parentName:"ol"},"A constructor in an abstract class can be called only when it is being initialized by a non-abstract subclass."),(0,i.kt)("li",{parentName:"ol"},"A method or class cannot marked as both ",(0,i.kt)("inlineCode",{parentName:"li"},"final")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"abstract"),"."),(0,i.kt)("li",{parentName:"ol"},"A method cannot be marked as both ",(0,i.kt)("inlineCode",{parentName:"li"},"private")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"abstract"),"."),(0,i.kt)("li",{parentName:"ol"},"A method can be marked as both ",(0,i.kt)("inlineCode",{parentName:"li"},"private")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"final"),"."),(0,i.kt)("li",{parentName:"ol"},"A ",(0,i.kt)("inlineCode",{parentName:"li"},"static")," method cannot be marked ",(0,i.kt)("inlineCode",{parentName:"li"},"abstract"),".")),(0,i.kt)("h3",{id:"immutable-object"},"Immutable Object"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Java is an OOP. States are stored in object."),(0,i.kt)("li",{parentName:"ol"},"States are, after all, variables which can eventually end up as object(s)."),(0,i.kt)("li",{parentName:"ol"},"If an outsider can change the internal states of an object, it will affect the functions, operations or calculations performed by this object."),(0,i.kt)("li",{parentName:"ol"},"Some people may think, as long as the instance variables are defined as private, setter is not defined, and that the constructor is defined private, outsiders cannot control the instantiation process or change its internal value."),(0,i.kt)("li",{parentName:"ol"},"The cruel fact is, as long as reference type is involved and that the outsiders hold a reference of internal variables of your target object in whatever way, even though they cannot reassign the reference, they can change the content of that reference."),(0,i.kt)("li",{parentName:"ol"},"Immutable objects pattern is an object-oriented design pattern in which an object cannot be modified after it is created."),(0,i.kt)("li",{parentName:"ol"},"Below is the strategy to make an object immutable:",(0,i.kt)("ol",{parentName:"li"},(0,i.kt)("li",{parentName:"ol"},"Mark the class final. ",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"So there is no way for other people to subclass your class to make it mutable."))),(0,i.kt)("li",{parentName:"ol"},"Make all the constructor private.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"So except via specific factory method or static method, no people can instantiate your class in whatever way via ",(0,i.kt)("inlineCode",{parentName:"li"},"new"),"."))),(0,i.kt)("li",{parentName:"ol"},"Mark all the instance variables ",(0,i.kt)("inlineCode",{parentName:"li"},"private")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"final"),".",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"private")," isolates the instance variables from outsiders."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"final")," does not allow reassignment of instance variables."))),(0,i.kt)("li",{parentName:"ol"},"Don't allow referenced mutable objects to be modified.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Instead of providing outsider getter method to access the reference mutable objects, provide ",(0,i.kt)("strong",{parentName:"li"},"delegate")," or ",(0,i.kt)("strong",{parentName:"li"},"wrapper")," method to outsider to read the data."))),(0,i.kt)("li",{parentName:"ol"},"Defensive copying",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"on the way in"),": the input parameters passed to constructor for instantiation of the target object will first make a copy inside the constructor. This way, even the outside may hold the reference of parameter and change its content, the target object is not affected.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java",metastring:"title='Without defensive copying'",title:"'Without",defensive:!0,"copying'":!0},'import java.util.ArrayList;\nimport java.util.List;\npublic class Test\n{\n    private final List<String> names;\n    public Test(List<String> names){\n        this.names = names;\n    }\n    public void print(){\n        System.out.println(names);\n    }\n    public static void main(String... args){\n        List<String> names = new ArrayList<String>(){ { add("John"); add("Mary"); add("June"); } };\n        Test test = new Test(names);\n        test.print(); // [John, Mary, June]\n        names.clear();\n        // This will error\n        test.print(); // [], the object is being changed by an outsider\n    }\n}\n')),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java",metastring:"title='With defensive copying'",title:"'With",defensive:!0,"copying'":!0},'import java.util.ArrayList;\nimport java.util.List;\npublic class Test\n{\n    private final List<String> names;\n    public Test(List<String> names){\n        #highlight-next-line\n        List<String> copy = new ArrayList<String>(names); // Defensive copying\n        this.names = copy;\n    }\n    public void print(){\n        System.out.println(names);\n    }\n    public static void main(String... args){\n        List<String> names = new ArrayList<String>(){ { add("John"); add("Mary"); add("June"); } };\n        Test test = new Test(names);\n        test.print(); // [John, Mary, June]\n        names.clear();\n        #highlight-next-line\n        test.print(); // [John, Mary, June]\n    }\n}\n'))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"on the way out"),": the output return type of the target object will always be a copy. Even outsiders hold the reference of this copy and make changes to it, the original target object will not be affected.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java",metastring:"title='Without defensive copying'",title:"'Without",defensive:!0,"copying'":!0},'import java.util.ArrayList;\nimport java.util.List;\npublic class Test\n{\n    private final List<String> names = new ArrayList<String>(){ { add("John"); add("Mary"); add("June"); } };;\n    public List<String> getNames(){\n        return names;\n    }\n    public static void main(String... args){\n        Test test = new Test();\n        List<String> names = test.getNames(); // [John, Mary, June]\n        System.out.println(names);\n        names.clear();\n        names = test.getNames();\n        // This will error\n        System.out.println(names); // [], the object is being changed by an outsider\n    }\n}\n')),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java",metastring:"title='With defensive copying'",title:"'With",defensive:!0,"copying'":!0},'import java.util.ArrayList;\nimport java.util.List;\npublic class Test\n{\n    private final List<String> names = new ArrayList<String>(){ { add("John"); add("Mary"); add("June"); } };;\n    public List<String> getNames(){\n        #highlight-next-line\n        return new ArrayList(names); // Defensive copying\n    }\n    public static void main(String... args){\n        Test test = new Test();\n        List<String> names = test.getNames(); // [John, Mary, June]\n        System.out.println(names);\n        names.clear();\n        names = test.getNames();\n        #highlight-next-line\n        System.out.println(names); // [John, Mary, June]\n    }\n}\n')))))))),(0,i.kt)("h2",{id:"beyond-classes"},"Beyond Classes"),(0,i.kt)("h3",{id:"top-level-type"},"Top level type"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Top level type includes:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"class"),(0,i.kt)("li",{parentName:"ul"},"enums"),(0,i.kt)("li",{parentName:"ul"},"records"),(0,i.kt)("li",{parentName:"ul"},"interface"),(0,i.kt)("li",{parentName:"ul"},"annotation"))),(0,i.kt)("li",{parentName:"ol"},"A Java file can have ",(0,i.kt)("strong",{parentName:"li"},"more than")," 1 top level type."),(0,i.kt)("li",{parentName:"ol"},"A Java file can have ",(0,i.kt)("strong",{parentName:"li"},"at most 1 public")," top level type."),(0,i.kt)("li",{parentName:"ol"},"Public top level type must match the name of the Java file."),(0,i.kt)("li",{parentName:"ol"},"A top level type can only be declared with public or package access."),(0,i.kt)("li",{parentName:"ol"},'A "top-level" type establishes a static context because it can be accessed without any enclosing instance.')),(0,i.kt)("h3",{id:"interface"},"Interface"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"An ",(0,i.kt)("strong",{parentName:"li"},"interface")," is an abstract data type that declares a list of abstract methods."),(0,i.kt)("li",{parentName:"ol"},"An ",(0,i.kt)("strong",{parentName:"li"},"implicit modifier")," is a modifier that the compiler automatically inserts into the code."),(0,i.kt)("li",{parentName:"ol"},"Interface variables are implicitly ",(0,i.kt)("inlineCode",{parentName:"li"},"public"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"static"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"final"),"."),(0,i.kt)("li",{parentName:"ol"},"Interface methods without a body are implicitly ",(0,i.kt)("inlineCode",{parentName:"li"},"abstract"),"."),(0,i.kt)("li",{parentName:"ol"},"Interface methods without the private modifier are implicitly ",(0,i.kt)("inlineCode",{parentName:"li"},"public"),"."),(0,i.kt)("li",{parentName:"ol"},"Interfaces are implicitly ",(0,i.kt)("inlineCode",{parentName:"li"},"abstract"),"."),(0,i.kt)("li",{parentName:"ol"},"Below 2 interface definitions are equivalent.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"interface InterfaceA \n{ \n    void method(); \n    int variable = 10 ;\n}\n")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"abstract interface InterfaceA \n{ \n    public abstract void method(); \n    public static final int variable = 10 ;\n}\n"))),(0,i.kt)("li",{parentName:"ol"},"An interface is not required to define methods."),(0,i.kt)("li",{parentName:"ol"},"An interface cannot be ",(0,i.kt)("inlineCode",{parentName:"li"},"final"),", as it is implicitly abstract. There is no sense marking an interface as final as no class can implement it."),(0,i.kt)("li",{parentName:"ol"},"Using ",(0,i.kt)("inlineCode",{parentName:"li"},"implements"),", a class can implement an interface ."),(0,i.kt)("li",{parentName:"ol"},"A class can implement multiple interfaces.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"interface InterfaceA {}\ninterface InterfaceB {}\ninterface InterfaceC {}\n#highlight-next-line\nclass classA implements InterfaceA, InterfaceB, InterfaceC{}\n"))),(0,i.kt)("li",{parentName:"ol"},"A class cannot extends an interface.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"interface InterfaceO{}\n#highlight-next-line\nclass ClassB implements InterfaceO{}\n// This will error\nclass ClassA extends InterfaceO{} // Compilation error - java: no interface expected here\n"))),(0,i.kt)("li",{parentName:"ol"},"Using ",(0,i.kt)("inlineCode",{parentName:"li"},"extends"),", an interface can extend another interface."),(0,i.kt)("li",{parentName:"ol"},"An interface can extend multiple interfaces.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"interface InterfaceA {}\ninterface InterfaceB {}\ninterface InterfaceC {}\n#highlight-next-line\ninterface InterfaceU extends InterfaceA, InterfaceB, InterfaceC{}\n"))),(0,i.kt)("li",{parentName:"ol"},"An interface cannot extend a class."),(0,i.kt)("li",{parentName:"ol"},"An interface cannot implement an interface.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java"},"interface InterfaceA {}\nclass ClassA {}\n#highlight-next-line\ninterface InterfaceB extends InterfaceA {}\n// This will error\ninterface InterfaceC implements InterfaceA {} // Compilation error - No interface clause allowed for interface\n// This will error\ninterface InterfaceD extends ClassA {} // Compilation error - interface expected here\n"))),(0,i.kt)("li",{parentName:"ol"},"An interface is not initialized as part of class hierarchy."),(0,i.kt)("li",{parentName:"ol"},"An interface does not contain constructor and are not part of instance initialization."),(0,i.kt)("li",{parentName:"ol"},"An interface is simply a contract. It defines a set of rules and methods that a class implementing it must follow."),(0,i.kt)("li",{parentName:"ol"},"When a concrete class inherits an interface, all of the inherited abstract methods must be implemented."),(0,i.kt)("li",{parentName:"ol"},"Java supports inheriting the same method from 2 interfaces that have compatible method declarations.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java",metastring:"title='Compatible method declaration'",title:"'Compatible",method:!0,"declaration'":!0},"interface InterfaceA { void methodA(); }\ninterface InterfaceB { void methodA(); }\nclass ClassU implements InterfaceA, InterfaceB {\n   public void methodA(){};\n}\n")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-java",metastring:"title='Incompatible method declaration'",title:"'Incompatible",method:!0,"declaration'":!0},"interface InterfaceA { String methodA(); }\ninterface InterfaceB { Integer methodA(); }\nclass ClassU implements InterfaceA, InterfaceB {\n    // This will error\n    public String methodA(){}; // Compilation error - ClassU is not abstract and does not override abstract method methodA() in InterfaceB\n}\n")))),(0,i.kt)("h2",{id:"lambdas-and-functional-interfaces"},"Lambdas And Functional Interfaces"))}c.isMDXComponent=!0}}]);